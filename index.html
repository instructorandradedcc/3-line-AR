<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Triángulos Conectados AR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        /* Estilo tipo cristal para la UI */
        .glass-panel {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
        }
        #ar-button-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20; }
    </style>
    
    <!-- Import Maps para Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- UI CAPA SUPERIOR -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">
        
        <!-- Pantalla de Login / Lobby -->
        <div id="lobby-screen" class="interactive absolute inset-0 bg-slate-900 flex items-center justify-center z-50">
            <div class="glass-panel p-8 rounded-xl max-w-md w-full text-center shadow-2xl">
                <h1 class="text-3xl font-bold mb-2 text-cyan-400">Triángulos AR</h1>
                <p class="text-gray-300 mb-6 text-sm">Conecta puntos, forma triángulos, gana.</p>
                
                <div class="mb-4 text-left">
                    <label class="text-xs text-gray-400 uppercase">Tu ID de Sala</label>
                    <input type="text" id="room-input" value="sala_demo" class="w-full bg-slate-800 border border-slate-600 p-3 rounded text-white focus:outline-none focus:border-cyan-500 transition">
                </div>

                <div class="grid grid-cols-2 gap-4 mb-6">
                    <button onclick="startGame('P1')" class="bg-blue-600 hover:bg-blue-500 py-3 rounded font-bold transition shadow-lg shadow-blue-900/50">Soy Jugador 1 (Azul)</button>
                    <button onclick="startGame('P2')" class="bg-red-600 hover:bg-red-500 py-3 rounded font-bold transition shadow-lg shadow-red-900/50">Soy Jugador 2 (Rojo)</button>
                </div>
                <p class="text-xs text-gray-500">Nota: Comparte el ID de sala para jugar con un amigo.</p>
            </div>
        </div>

        <!-- HUD del Juego (Oculto inicialmente) -->
        <div id="game-hud" class="hidden flex-col h-full justify-between">
            <!-- Top Bar: Marcador -->
            <div class="glass-panel p-3 rounded-lg flex justify-between items-center shadow-lg">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-blue-500 shadow-[0_0_10px_#3b82f6]"></div>
                    <span class="font-bold text-blue-400">P1: <span id="score-p1">0</span></span>
                </div>
                <div class="text-center">
                    <div id="turn-indicator" class="px-3 py-1 rounded-full bg-slate-700 text-xs font-bold border border-slate-500 animate-pulse">
                        ESPERANDO...
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <span class="font-bold text-red-400">P2: <span id="score-p2">0</span></span>
                    <div class="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_#ef4444]"></div>
                </div>
            </div>

            <!-- Instrucciones Inferiores -->
            <div class="text-center pb-16 pointer-events-none">
                <p id="game-msg" class="text-sm text-white drop-shadow-md bg-black/30 inline-block px-4 py-1 rounded-full backdrop-blur-sm">
                    Toca dos puntos cercanos para conectarlos.
                </p>
            </div>
        </div>
    </div>

    <!-- Contenedor para botón AR -->
    <div id="ar-button-container" class="interactive"></div>

    <!-- Módulos JS -->
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, doc, onSnapshot, setDoc, updateDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // --- CONFIGURACIÓN FIREBASE ---
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
        
        // --- ESTADO GLOBAL ---
        let state = {
            roomId: "",
            myPlayerId: null, // "P1" o "P2"
            currentPlayer: "P1",
            lines: [], // {start: pointIdx, end: pointIdx, owner: "P1"}
            triangles: [], // {points: [a,b,c], owner: "P1"}
            scores: { P1: 0, P2: 0 },
            ready: false
        };

        // --- CONFIGURACIÓN 3D ---
        let camera, scene, renderer, controller;
        let raycaster = new THREE.Raycaster();
        let pointer = new THREE.Vector2();
        let controls; // OrbitControls para modo escritorio
        
        // Objetos de la escena
        let gridPoints = []; // Meshes de los puntos
        let gridGroup; // Grupo que contiene todo el tablero (para moverlo en AR)
        let previewLine; // Línea temporal al arrastrar/seleccionar
        let selectedStartPoint = null; // Primer punto seleccionado

        // Configuración de la cuadrícula (Triangular Lattice para mejores triángulos)
        // Usaremos una cuadrícula simple desplazada para facilitar triángulos equiláteros visualmente
        const GRID_ROWS = 4;
        const GRID_COLS = 4;
        const SPACING = 0.15; // Metros en AR

        // --- INICIALIZACIÓN ---

        window.startGame = async (role) => {
            const roomInput = document.getElementById('room-input').value.trim();
            if(!roomInput) return alert("Ingresa un nombre de sala");
            
            state.roomId = roomInput;
            state.myPlayerId = role;
            
            // Autenticación Firebase
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }

            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('game-hud').classList.remove('hidden');
            document.getElementById('game-hud').style.display = 'flex';

            init3D();
            setupFirebaseListener();
        };

        function init3D() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 2, 0.5);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Botón AR
            const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
            document.getElementById('ar-button-container').appendChild(arButton);

            // Grupo del tablero
            gridGroup = new THREE.Group();
            // Posicionar el tablero frente a la cámara por defecto para modo escritorio
            gridGroup.position.set(-0.25, -0.2, -0.8); 
            scene.add(gridGroup);

            createGrid();

            // Interacciones (Toque/Click)
            // Para WebXR (Móvil AR)
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelectAR);
            scene.add(controller);

            // Para Escritorio (Mouse)
            window.addEventListener('click', onClickDesktop);
            window.addEventListener('resize', onWindowResize);

            // Orbit Controls para debug en escritorio
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, -1);
            controls.update();

            animate();
        }

        function createGrid() {
            // Crear puntos (Esferas)
            const geometry = new THREE.SphereGeometry(0.015, 16, 16); // 1.5cm radio
            const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.5 });

            let idx = 0;
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const sphere = new THREE.Mesh(geometry, material.clone());
                    
                    // Offset para crear patrón triangular (hexagonal)
                    const xOffset = (row % 2) * (SPACING / 2); 
                    
                    sphere.position.set(
                        col * SPACING + xOffset - (GRID_COLS * SPACING)/2, 
                        0, // Plano en el suelo (XZ)
                        row * (SPACING * 0.866) - (GRID_ROWS * SPACING * 0.866)/2 // 0.866 es sin(60deg) para equiláteros
                    );
                    
                    sphere.userData = { id: idx, isDot: true };
                    gridGroup.add(sphere);
                    gridPoints.push(sphere);
                    idx++;
                }
            }
        }

        // --- LÓGICA DEL JUEGO ---

        function handleInput(intersectedObject) {
            if (!intersectedObject || !state.ready) return;
            if (state.currentPlayer !== state.myPlayerId) {
                showToast("¡Espera tu turno!");
                return;
            }

            const dot = intersectedObject.userData;

            // Lógica de selección
            if (selectedStartPoint === null) {
                // Primer clic
                selectedStartPoint = intersectedObject;
                intersectedObject.material.color.set(0xffff00); // Amarillo selección
                intersectedObject.scale.set(1.5, 1.5, 1.5);
                showToast("Selecciona un punto adyacente");
            } else {
                // Segundo clic
                if (selectedStartPoint === intersectedObject) {
                    // Cancelar selección
                    resetSelection();
                    return;
                }

                const startId = selectedStartPoint.userData.id;
                const endId = dot.id;

                // Validar distancia (solo vecinos cercanos)
                const dist = selectedStartPoint.position.distanceTo(intersectedObject.position);
                // SPACING es 0.15. Permitimos un pequeño margen de error (0.16)
                if (dist > SPACING * 1.2) {
                    showToast("¡Puntos demasiado lejos!");
                    resetSelection();
                    return;
                }

                // Validar si la línea ya existe
                const exists = state.lines.some(l => 
                    (l.start === startId && l.end === endId) || (l.start === endId && l.end === startId)
                );

                if (exists) {
                    showToast("Esa línea ya existe");
                    resetSelection();
                    return;
                }

                // MOVIMIENTO VÁLIDO: Enviar a Firebase
                submitMove(startId, endId);
                resetSelection();
            }
        }

        function resetSelection() {
            if (selectedStartPoint) {
                selectedStartPoint.material.color.set(0xffffff);
                selectedStartPoint.scale.set(1, 1, 1);
            }
            selectedStartPoint = null;
        }

        // --- FIREBASE SYNC ---

        function getGameRef() {
            return doc(db, 'artifacts', appId, 'public', 'data', `game_${state.roomId}`);
        }

        async function setupFirebaseListener() {
            const gameRef = getGameRef();
            
            // Listener
            onSnapshot(gameRef, (snapshot) => {
                if (!snapshot.exists()) {
                    // Si no existe, la creamos
                    if (state.myPlayerId === 'P1') initializeGameDoc();
                } else {
                    const data = snapshot.data();
                    updateGameState(data);
                }
            }, (error) => {
                console.error("Error en listener:", error);
                showToast("Error de conexión");
            });
        }

        async function initializeGameDoc() {
            const gameRef = getGameRef();
            await setDoc(gameRef, {
                currentPlayer: 'P1',
                lines: [],
                scores: { P1: 0, P2: 0 },
                createdAt: new Date().toISOString()
            });
        }

        async function submitMove(startId, endId) {
            const gameRef = getGameRef();
            const newLine = { start: startId, end: endId, owner: state.myPlayerId };
            
            // Lectura optimista o transacción para validar
            // Aquí hacemos una actualización directa por simplicidad del prototipo, 
            // pero en producción usaríamos una transacción para evitar conflictos.
            
            // Calculamos localmente si formó triángulo para actualizar score
            const currentLines = [...state.lines, newLine];
            const newTriangles = detectNewTriangles(newLine, currentLines);
            
            let nextPlayer = state.myPlayerId === 'P1' ? 'P2' : 'P1';
            let scoreUpdate = {};
            let pointsGained = 0;

            if (newTriangles.length > 0) {
                // Si hizo punto, repite turno
                nextPlayer = state.myPlayerId;
                pointsGained = newTriangles.length;
                scoreUpdate = { 
                    [`scores.${state.myPlayerId}`]: state.scores[state.myPlayerId] + pointsGained 
                };
                showToast(`¡Triángulo completado! (+${pointsGained})`);
            }

            // Actualizar documento
            try {
                // Nota: Firestore arrayUnion es mejor, pero aquí reemplazamos todo el array para simplificar lógica
                // Necesitamos leer el estado actual para asegurar no sobrescribir movimientos de otros milisegundos antes
                // Simplificamos asumiendo sincronización rápida
                
                const updatePayload = {
                    lines: currentLines,
                    currentPlayer: nextPlayer,
                    ...scoreUpdate
                };
                
                await updateDoc(gameRef, updatePayload);
                
            } catch (e) {
                console.error("Error enviando movimiento:", e);
            }
        }

        function updateGameState(data) {
            state.ready = true;
            state.currentPlayer = data.currentPlayer;
            state.scores = data.scores;
            
            // Actualizar UI
            document.getElementById('score-p1').innerText = data.scores.P1;
            document.getElementById('score-p2').innerText = data.scores.P2;
            
            const turnBadge = document.getElementById('turn-indicator');
            if (state.currentPlayer === state.myPlayerId) {
                turnBadge.innerText = "TU TURNO";
                turnBadge.className = "px-3 py-1 rounded-full bg-green-600 text-white text-xs font-bold animate-pulse";
            } else {
                turnBadge.innerText = `TURNO ${state.currentPlayer}`;
                turnBadge.className = "px-3 py-1 rounded-full bg-gray-600 text-gray-300 text-xs font-bold";
            }

            // Actualizar Tablero 3D
            // 1. Dibujar nuevas líneas
            // Limpiamos líneas viejas (ineficiente pero seguro para MVP)
            // Mejor: Solo añadir las nuevas.
            // Vamos a limpiar el grupo de líneas y repintar.
            
            // Remover líneas y triángulos visuales previos
            const toRemove = [];
            gridGroup.children.forEach(child => {
                if (child.userData.isLine || child.userData.isTriangle) toRemove.push(child);
            });
            toRemove.forEach(c => gridGroup.remove(c));

            state.lines = data.lines || [];
            state.lines.forEach(lineData => {
                drawLine3D(lineData.start, lineData.end, lineData.owner);
            });

            // 2. Detectar y dibujar triángulos (Recalculamos todo para asegurar sync visual)
            const allTriangles = findAllTriangles(state.lines);
            allTriangles.forEach(tri => {
                drawTriangle3D(tri.points, tri.owner);
            });
        }

        // --- ALGORITMOS GEOMÉTRICOS ---

        function drawLine3D(startId, endId, ownerId) {
            const p1 = gridPoints[startId].position;
            const p2 = gridPoints[endId].position;
            
            const color = ownerId === 'P1' ? 0x3b82f6 : 0xef4444; // Azul o Rojo

            // Usamos Cilindro para la línea (más visible en AR que GL_LINES)
            const distance = p1.distanceTo(p2);
            const geometry = new THREE.CylinderGeometry(0.005, 0.005, distance, 8);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const cylinder = new THREE.Mesh(geometry, material);
            
            // Orientar cilindro
            const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            cylinder.position.copy(midPoint);
            cylinder.lookAt(p2);
            cylinder.rotateX(Math.PI / 2); // Three.js cylinders stand up by default

            cylinder.userData = { isLine: true };
            gridGroup.add(cylinder);
        }

        function drawTriangle3D(pointIds, ownerId) {
            const pA = gridPoints[pointIds[0]].position;
            const pB = gridPoints[pointIds[1]].position;
            const pC = gridPoints[pointIds[2]].position;

            const shape = new THREE.Shape();
            shape.moveTo(0,0);
            // Esto requiere proyectar puntos a un plano 2D local para crear la geometría Shape, 
            // pero como son triángulos 3D simples, usamos BufferGeometry.
            
            const geom = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                pA.x, pA.y, pA.z,
                pB.x, pB.y, pB.z,
                pC.x, pC.y, pC.z
            ]);
            geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            // Necesitamos 2 caras para que se vea por ambos lados
            geom.setIndex([0, 1, 2, 2, 1, 0]); 
            geom.computeVertexNormals();

            const color = ownerId === 'P1' ? 0x3b82f6 : 0xef4444;
            const mat = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.4, 
                side: THREE.DoubleSide 
            });
            
            const mesh = new THREE.Mesh(geom, mat);
            mesh.userData = { isTriangle: true };
            gridGroup.add(mesh);
        }

        // Algoritmo para detectar triángulos formados por líneas
        function findAllTriangles(lines) {
            // Crear mapa de adyacencia
            const adj = {};
            lines.forEach(l => {
                if (!adj[l.start]) adj[l.start] = [];
                if (!adj[l.end]) adj[l.end] = [];
                adj[l.start].push({ to: l.end, owner: l.owner });
                adj[l.end].push({ to: l.start, owner: l.owner });
            });

            const triangles = [];
            const seen = new Set(); // Para evitar duplicados (A-B-C es igual a B-C-A)

            // Buscar ciclos de longitud 3
            // Iterar sobre cada punto 'u'
            for (const u in adj) {
                const neighbors = adj[u];
                // Pares de vecinos
                for (let i = 0; i < neighbors.length; i++) {
                    for (let j = i + 1; j < neighbors.length; j++) {
                        const v = neighbors[i].to;
                        const w = neighbors[j].to;
                        
                        // ¿Existe conexión directa entre v y w?
                        // Verificar si v tiene w en su lista
                        if (adj[v] && adj[v].some(n => n.to == w)) {
                            // ¡Triángulo encontrado! {u, v, w}
                            // Determinar el "dueño". En este juego, el dueño es quien puso la ÚLTIMA línea.
                            // Pero para renderizado histórico, podemos simplificar asumiendo el color de la mayoría o del último.
                            // Como este juego rellena al instante, Firestore ya debería tener los triángulos guardados si quisiéramos persistencia estricta,
                            // pero aquí recalculamos. Asignaremos el color basado en la línea que cerró (difícil saber aquí sin timestamp).
                            // HACK VISUAL: Usamos el color del jugador actual si es nuevo, o alternamos. 
                            // MEJOR: Buscar la línea en 'lines' array para saber el owner de cada arista, pero el triángulo es una entidad propia.
                            // Para el MVP, asignaremos el dueño de la línea entre v y w (arbitrario para rendering estático).
                            
                            const ids = [parseInt(u), v, w].sort((a,b) => a-b);
                            const key = ids.join('-');
                            if (!seen.has(key)) {
                                seen.add(key);
                                // Buscamos quién cerró. No tenemos historial temporal aquí fácil.
                                // Asignamos el owner de la primera línea encontrada para el color (simplificación visual).
                                triangles.push({ points: ids, owner: neighbors[i].owner }); 
                            }
                        }
                    }
                }
            }
            return triangles;
        }

        function detectNewTriangles(newLine, allLines) {
            // Verifica solo si newLine cierra triángulos
            const adj = {}; 
            // Construir adyacencia solo necesaria
            allLines.forEach(l => {
                if (!adj[l.start]) adj[l.start] = [];
                if (!adj[l.end]) adj[l.end] = [];
                adj[l.start].push(l.end);
                adj[l.end].push(l.start);
            });

            const u = newLine.start;
            const v = newLine.end;
            const newTris = [];

            // Buscar nodos 'w' conectados a AMBOS u y v
            if (adj[u] && adj[v]) {
                adj[u].forEach(w => {
                    if (w !== v && adj[v].includes(w)) {
                        // Triángulo u-v-w encontrado
                        newTris.push([u, v, w]);
                    }
                });
            }
            return newTris;
        }

        // --- INTERACCIÓN ---

        function onSelectAR() {
            // Raycast desde el controlador VR/AR
            // En Three.js WebXR, el 'select' event ya implica un toque.
            // Usamos una matriz de referencia temporal del controlador para raycasting
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);

            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const intersects = raycaster.intersectObjects(gridPoints);
            if (intersects.length > 0) {
                handleInput(intersects[0].object);
            }
        }

        function onClickDesktop(event) {
            // Raycast desde el mouse
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(gridPoints);

            if (intersects.length > 0) {
                handleInput(intersects[0].object);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            renderer.render(scene, camera);
        }

        function showToast(msg) {
            const el = document.getElementById('game-msg');
            el.innerText = msg;
            el.classList.remove('hidden');
            setTimeout(() => {
                if(el.innerText === msg) el.innerText = "Tu turno"; // Reset msg
            }, 2000);
        }

    </script>
</body>
</html>


