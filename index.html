<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Aseguramos la máxima escalabilidad y compatibilidad AR -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3 LINE-AR | V37.0 FIX ALL</title>
    
    <!-- Dependencias -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { 
            theme: { 
                extend: { 
                    colors: { glass: 'rgba(5, 10, 20, 0.95)', cyber: '#00f3ff', neon: '#39ff14', hot: '#ff0055', warn: '#ffcc00' },
                    fontFamily: { orbitron: ['Orbitron', 'sans-serif'], mono: ['monospace'] },
                    animation: { 'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite' }
                } 
            } 
        }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; font-family: 'Orbitron', sans-serif; -webkit-tap-highlight-color: transparent; }
        
        /* FONDO */
        #bg-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; background: radial-gradient(circle at center, #080810 0%, #000000 100%); pointer-events: none; transition: opacity 0.5s; }
        
        canvas { display: block; outline: none; } 
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        .interactive { pointer-events: auto; }
        
        /* PANELES */
        .glass-panel {
            background: rgba(8, 12, 18, 0.95); backdrop-filter: blur(16px);
            border: 1px solid rgba(0, 243, 255, 0.3); box-shadow: 0 0 40px rgba(0, 243, 255, 0.15);
            border-radius: 12px;
        }
        .btn-neon {
            background: linear-gradient(180deg, rgba(0,243,255,0.1), rgba(0,243,255,0));
            border: 1px solid #00f3ff; color: #00f3ff; font-weight: 800;
            text-transform: uppercase; letter-spacing: 2px; transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2); cursor: pointer;
        }
        .btn-neon:active { transform: scale(0.95); background: #00f3ff; color: #000; }
        .btn-neon.danger { border-color: #ff0055; color: #ff0055; }

        /* DADO */
        .dice-wrap { perspective: 800px; width: 70px; height: 70px; pointer-events: auto; cursor: pointer; }
        .dice-cube {
            width: 100%; height: 100%; position: relative; transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            background: rgba(0,0,0,0.9); border: 2px solid #00f3ff; border-radius: 12px;
            display: flex; justify-content: center; align-items: center;
            font-size: 36px; color: #00f3ff; text-shadow: 0 0 15px #00f3ff;
        }
        .rolling { animation: shake 0.4s infinite; background: #00f3ff; color: #000; text-shadow: none; }
        @keyframes shake { 0%,100% { transform: rotate(0deg); } 25% { transform: rotate(10deg); } 75% { transform: rotate(-10deg); } }

        /* TOAST & LOADERS */
        .toast-box {
            background: #000; border: 1px solid #00f3ff; border-left-width: 5px;
            padding: 12px 24px; color: white; font-size: 11px; font-family: 'monospace';
            transform: translateY(100px); opacity: 0; transition: all 0.4s;
        }
        .toast-box.show { transform: translateY(0); opacity: 1; }
        
        #game-toast {
            background: rgba(8, 12, 18, 0.95); backdrop-filter: blur(8px);
            border: 1px solid #00f3ff; border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            min-width: 200px; max-width: 90%;
            padding: 8px 12px;
            opacity: 0;
            transform: translateY(-5px);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        #game-toast.show { opacity: 1; transform: translateY(0); }


        #mini-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; pointer-events: none; }
        
        /* PANTALLA VICTORIA */
        #win-screen { 
            position: absolute; inset: 0; background: rgba(0,0,0,0.98); z-index: 60; 
            pointer-events: auto; display: none !important; 
            flex-direction: column; justify-content: center; align-items: center;
        }
        #win-screen.active { display: flex !important; }

        /* SELECTOR */
        .opt { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #333; cursor: pointer; transition: 0.2s; transform: scale(0.9); pointer-events: auto; }
        .opt.active { border-color: white; transform: scale(1.2); box-shadow: 0 0 20px currentColor; border-width: 2px; }
        .opt-i { font-size: 24px; color: #555; transition: 0.2s; cursor: pointer; pointer-events: auto; }
        .opt-i.active { color: #00f3ff; transform: scale(1.3); text-shadow: 0 0 15px #00f3ff; }

        /* AR Button Override: Usamos este selector global para dar estilo al botón creado por Three.js */
        #ar-zone button {
            background: rgba(20, 20, 30, 0.95) !important; border: 1px solid #00f3ff !important;
            color: #00f3ff !important; font-family: 'Orbitron' !important; padding: 12px 24px !important;
            border-radius: 6px !important; text-transform: uppercase !important;
            transition: background 0.2s; /* Aseguramos la transición para iOS/Safari */
            pointer-events: auto !important; /* Es crucial para que el botón funcione */
        }

        /* Estilo para el botón de Recenter en AR (Sustituido por AR-Hint) */
        #btn-rec {
            display: flex; /* Mantenemos flex para modo 3D */
        }
        .ar-sync-btn {
            background: rgba(255, 204, 0, 0.1) !important; border: 1px solid #ffcc00 !important;
            color: #ffcc00 !important; font-family: 'Orbitron' !important; padding: 8px 16px !important;
            border-radius: 6px !important; text-transform: uppercase !important;
            font-size: 10px; font-weight: bold;
        }
        .ar-sync-btn:active { transform: scale(0.95); background: #ffcc00; color: #000; }
        
        .btn-end {
            background: rgba(255, 0, 85, 0.1); /* hot */
            border: 1px solid #ff0055;
            color: #ff0055;
            font-size: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .btn-end:active { transform: scale(0.95); background: #ff0055; color: #000; }

    </style>

    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }</script>
</head>
<body>
    <!-- Canvas para el fondo estático 3D -->
    <canvas id="bg-canvas"></canvas>

    <div id="ui-layer" class="flex flex-col justify-between p-4 h-full">
        
        <!-- 1. PANTALLA DE LOGIN -->
        <!-- Z-index 50 para cubrir todo antes de auth -->
        <div id="s-login" class="interactive absolute inset-0 flex items-center justify-center bg-black/95 z-50">
            <div class="glass-panel p-8 text-center w-full max-w-xs flex flex-col items-center gap-6">
                <div class="text-6xl text-cyber animate-pulse-fast"><i class="fas fa-globe-network"></i></div>
                <div>
                    <h1 class="text-4xl font-black text-white italic tracking-tighter">3 LINE<span class="text-cyber">-AR</span></h1>
                    <!-- Versión visible -->
                    <p class="text-gray-500 text-[9px] font-mono tracking-[0.4em] mt-2">V37.0 FIX ALL</p>
                </div>
                <button onclick="window.doLogin()" class="btn-neon w-full py-4 flex justify-center items-center gap-3 text-sm hover:bg-cyber/10">
                    <i class="fab fa-google"></i> INICIAR SESIÓN
                </button>
                <p id="login-msg" class="text-[9px] text-gray-600">SISTEMA EN ESPERA</p>
            </div>
        </div>

        <!-- 2. PANTALLA DE MENÚ -->
        <!-- Z-index 40 para ser visible después de auth -->
        <div id="s-menu" class="interactive absolute inset-0 flex items-center justify-center bg-black/90 z-40 hidden">
            <div class="glass-panel p-6 w-full max-w-xs flex flex-col gap-5">
                <div class="flex justify-between items-center border-b border-white/10 pb-3">
                    <div><span class="text-[9px] text-cyber block tracking-widest">AGENTE</span><span id="u-name" class="text-white font-bold text-lg">...</span></div>
                    <button onclick="window.logout()" class="w-8 h-8 rounded border border-danger text-danger flex items-center justify-center hover:bg-danger hover:text-white transition"><i class="fas fa-power-off"></i></button>
                </div>

                <div class="bg-white/5 p-4 rounded border border-white/10 pointer-events-auto">
                    <div class="flex justify-between items-center mb-4">
                        <span class="text-[9px] text-gray-400 font-bold">COLOR</span>
                        <div class="flex gap-3" id="c-pick">
                            <div onclick="window.setProf('c','#00f3ff',this)" class="opt bg-[#00f3ff] active" style="box-shadow:0 0 15px #00f3ff"></div>
                            <div onclick="window.setProf('c','#ff0055',this)" class="opt bg-[#ff0055]"></div>
                            <div onclick="window.setProf('c','#39ff14',this)" class="opt bg-[#39ff14]"></div>
                            <div onclick="window.setProf('c','#ffd700',this)" class="opt bg-[#ffd700]"></div>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-[9px] text-gray-400 font-bold">MARCA</span>
                        <div class="flex gap-4 text-lg" id="i-pick">
                            <i onclick="window.setProf('i','gem',this)" class="opt-i fas fa-gem active"></i>
                            <i onclick="window.setProf('i','bolt',this)" class="opt-i fas fa-bolt"></i>
                            <i onclick="window.setProf('i','star',this)" class="opt-i fas fa-star"></i>
                            <i onclick="window.setProf('i','atom',this)" class="opt-i fas fa-atom"></i>
                        </div>
                    </div>
                </div>

                <button onclick="window.quickMatch()" class="btn-neon py-5 text-lg shadow-lg"><i class="fas fa-globe mr-2"></i> PARTIDA PÚBLICA</button>
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="window.createRoom()" class="btn-neon py-3 text-xs">CREAR SALA</button>
                    <button onclick="window.showJoin()" class="btn-neon py-3 text-xs">UNIRSE</button>
                </div>
                <div id="join-box" class="hidden flex gap-2 mt-1 animate-fade-in">
                    <input id="code-in" class="bg-black/50 border border-cyber text-white w-full text-center p-3 uppercase font-mono text-lg tracking-widest" placeholder="CÓDIGO" maxlength="4">
                    <button onclick="window.joinRoom()" class="btn-neon w-14"><i class="fas fa-arrow-right"></i></button>
                </div>
                <!-- Texto actualizado a 'JUGAR CONTRA LA MÁQUINA' -->
                <button onclick="window.vsCpu()" class="btn-neon danger py-3 text-xs mt-2"><i class="fas fa-microchip mr-2"></i> JUGAR CONTRA LA MÁQUINA</button>
                <div id="ar-status" class="text-center mt-2 text-[9px] text-gray-500 font-mono">VERIFICANDO HARDWARE...</div>
                <div id="version-lbl" class="text-center mt-2 text-[8px] text-gray-700 font-mono tracking-widest">V37.0 FIX ALL</div>
            </div>
        </div>

        <!-- 3. JUEGO HUD -->
        <div id="s-game" class="hidden flex flex-col justify-between h-full pointer-events-none relative z-10">
            <!-- HUD SUPERIOR -->
            <div class="interactive glass-panel p-3 flex justify-between items-start mt-2 mx-2 backdrop-blur-md">
                <div class="text-center w-20">
                    <span class="text-[8px] text-gray-400 block tracking-widest">PUNTAJE</span>
                    <span id="sc-p1" class="text-3xl text-white font-black leading-none">0</span>
                </div>
                
                <div class="flex flex-col items-center -mt-10 z-20">
                    <div class="dice-wrap" onclick="window.rollDice()"><div id="dice-vis" class="dice-cube"><i class="fas fa-dice-d20"></i></div></div>
                    
                    <!-- Mensaje de estado del juego (CONQUISTA/LÍNEA) -->
                    <div id="game-toast" class="text-center mt-2 interactive">
                        <p id="t-head" class="font-bold text-cyber text-xs mb-1 border-b border-white/10 pb-1 uppercase tracking-widest">SISTEMA</p>
                        <p id="t-body" class="text-sm tracking-wide">Mensaje</p>
                    </div>

                    <div id="mov-hud" class="bg-black/90 px-3 py-1 mt-3 rounded border border-cyber text-center opacity-0 transition-opacity min-w-[120px] shadow-lg flex items-center justify-between gap-2">
                        <div>
                            <p class="text-[7px] text-gray-400 tracking-widest">LÍNEAS</p><p id="mov-cnt" class="text-xl text-cyber font-bold leading-none">0</p>
                        </div>
                        <!-- Botón para indicar que no hay jugadas y pasar turno -->
                        <button onclick="window.skipTurn()" class="text-[8px] text-red-500 border border-red-500 px-2 py-1 rounded hover:bg-red-500 hover:text-white transition font-bold leading-tight">SIN<br>JUGADAS</button>
                    </div>
                </div>
                <div class="text-center w-20">
                    <span class="text-[8px] text-gray-400 block tracking-widest">RIVAL</span>
                    <span id="sc-p2" class="text-3xl text-white font-black leading-none">0</span>
                </div>
            </div>
            
            <div class="text-center mt-2 pointer-events-none"><span class="bg-black/60 text-[10px] px-4 py-1 rounded-full text-cyber border border-cyber/30 backdrop-blur font-bold">SALA: <span id="room-lbl" class="text-white">--</span></span></div>

            <div id="mini-loader" class="hidden text-center"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-cyber mx-auto mb-2"></div><span id="mini-load-txt" class="bg-black/80 text-cyber text-[10px] px-2 py-1 rounded border border-cyber">CARGANDO...</span></div>

            <div id="ar-hint" class="absolute top-24 left-1/2 -translate-x-1/2 pointer-events-none hidden flex-col items-center z-0">
                <div class="w-20 h-20 border-2 border-cyber rounded-full animate-ping absolute opacity-30"></div>
                <span id="ar-scan-text" class="bg-black/80 text-[10px] px-3 py-2 text-cyber border border-cyber rounded mt-4 font-bold tracking-widest backdrop-blur">ESCANEA SUPERFICIE</span>
                <span id="ar-scale-hint" class="hidden mt-2 text-[8px] text-white bg-black/50 px-2 rounded">PELLIZCA PARA ESCALAR</span>
            </div>

            <!-- Toast inferior (Mantener para mensajes de sistema o errores) -->
            <div class="flex justify-center items-center flex-grow pointer-events-none absolute bottom-1/2 left-1/2 -translate-x-1/2 translate-y-1/2">
                <div id="toast" class="toast-box text-center"><p id="s-head" class="font-bold text-cyber text-xs mb-1 border-b border-white/10 pb-1 uppercase tracking-widest">SISTEMA</p><p id="s-body" class="text-sm tracking-wide">Mensaje</p></div>
            </div>

            <div class="interactive flex justify-center gap-6 pb-24 md:pb-10 items-end">
                <button onclick="window.finishGame()" class="btn-end flex items-center gap-1"><i class="fas fa-flag-checkered"></i> FINALIZAR JUEGO</button>
                <button onclick="window.goHome()" class="w-14 h-14 rounded-full bg-gray-800/90 border border-gray-600 text-gray-300 flex flex-col items-center justify-center shadow-lg hover:border-white hover:text-white transition"><i class="fas fa-home text-lg"></i><span class="text-[8px] font-bold mt-1">INICIO</span></button>
                <!-- Botón de recentrar que se oculta en AR y se usa para el modo 3D -->
                <button onclick="window.recenter()" id="btn-rec" class="px-6 h-12 rounded-full bg-cyber/10 border border-cyber text-cyber text-xs font-mono shadow-[0_0_15px_rgba(0,243,255,0.2)] hover:bg-cyber/30 hover:text-white transition flex items-center gap-2"><i class="fas fa-compress-arrows-alt"></i> RE-CENTRAR</button>
            </div>
            
            <!-- Controles de AR: Solo visibles en sesión AR y después de la colocación -->
            <div id="ar-controls" class="interactive absolute bottom-4 left-1/2 -translate-x-1/2 hidden justify-center gap-4 z-40">
                <button onclick="window.acceptScaleAndPosition()" id="btn-ar-accept" class="ar-sync-btn"><i class="fas fa-check mr-2"></i> ACEPTAR POSICIÓN</button>
                <button onclick="window.recalibrate()" id="btn-ar-recal" class="ar-sync-btn"><i class="fas fa-sync-alt mr-2"></i> RECALIBRAR</button>
            </div>
        </div>

        <div id="win-screen">
            <h1 id="win-title" class="text-6xl font-black text-cyber mb-2 animate-pulse text-center">VICTORIA</h1>
            <p id="win-msg" class="text-white font-mono mb-8 tracking-widest text-center">AGENTE DOMINANTE</p>
            <div class="flex gap-8 text-center mb-8">
                <div><span class="text-gray-500 text-xs block">TU PUNTAJE</span><span id="final-p1" class="text-4xl font-bold text-white">0</span></div>
                <div><span class="text-gray-500 text-xs block">RIVAL</span><span id="final-p2" class="text-4xl font-bold text-white">0</span></div>
            </div>
            <!-- CORRECCIÓN: Volver al menú después de la pantalla de victoria -->
            <button onclick="window.goHomeAfterWin()" class="btn-neon py-4 px-10 text-lg">VOLVER AL MENÚ</button>
        </div>
    </div>

    <!-- Zona de botones AR. Contiene el botón nativo de WebXR creado por Three.js -->
    <div id="ar-zone" class="absolute bottom-8 left-1/2 -translate-x-1/2 interactive z-30 w-full flex justify-center pointer-events-none"></div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, updateDoc, onSnapshot, getDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Configuración y variables globales
        setLogLevel('Debug');
        // Usamos una configuración de ejemplo si no se encuentran las variables globales
        const defaultConf = { apiKey:"AIzaSyBbPYnUPaO-kzWWStS8013SOvdTSuK3KP4", authDomain:"ar-3lilne.firebaseapp.com", projectId:"ar-3lilne", appId:"1:382966716480:web:ee244825bb34bc35c667a5" };
        const firebaseConfig = (typeof __firebase_config !== 'undefined' && __firebase_config) ? JSON.parse(__firebase_config) : defaultConf;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'ar-3lilne-flux';
        
        let app, auth, db;
        try { 
            app = initializeApp(firebaseConfig); 
            auth = getAuth(app); 
            db = getFirestore(app); 

            // ** CORRECCIÓN DE AUTENTICACIÓN: Usar Custom Token si está disponible **
            if (typeof __initial_auth_token !== 'undefined') {
                signInWithCustomToken(auth, __initial_auth_token).catch(e => console.error("Custom token sign in failed:", e));
            } else {
                console.log("Esperando inicio de sesión manual...");
            }
        } catch(e) { console.error("Firebase initialization failed:", e); }

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            if(type === 'click') { osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(300, now + 0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); } 
            else if(type === 'win') { osc.type = 'triangle'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); } 
            else if(type === 'roll') { osc.type = 'square'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); } 
            else if(type === 'error') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now + 0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.2); osc.start(now); osc.stop(now + 0.2); }
            else if(type === 'end') { osc.type = 'sine'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(600, now + 0.5); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0); osc.start(now); osc.stop(now + 1.0); }
        }

        let S = { user:null, room:null, role:null, cpu:false, data:null, prof:{c:'#00f3ff', i:'gem'} };
        let pts=[], selPt=null, placed=false, roomUnsub=null, gameStartTime=0, currentScale=1.0;
        // Mensajes aleatorios motivadores
        const LOSE_MSGS = ["¡BUEN INTENTO!", "LA PRÓXIMA SERÁ TUYA", "GRAN ESTRATEGIA", "BUENA PARTIDA", "SIGUE ASÍ", "TE ESPERO EN LA REVANCHA", "CASI LO LOGRAS, CAMPEÓN"];

        // Variables para sincronización AR
        let arInitialized = false;
        let isArHost = false; // Indica si este usuario está a cargo de la colocación inicial
        let placementAccepted = false; // El host ya aceptó la colocación

        // THREE.JS & AR SETUP
        let scene, cam, ren, group, ray, reticle, arHit, controls, arRefSpace;
        let touchDist = 0;
        
        // Handler único para el evento 'select' (tap/click en AR)
        const onControllerSelect = () => {
            if (ren.xr.isPresenting && isArHost && !placed && reticle.visible) {
                // Solo ejecutamos la lógica de colocación si es Host, no está colocado y el reticle es visible
                placed = true; 
                reticle.visible = false;
                
                // Aplicar la transformación del reticle al grupo
                group.position.setFromMatrixPosition(reticle.matrix); 
                group.rotation.setFromRotationMatrix(reticle.matrix);
                group.visible = true;

                // Actualizar UI
                document.getElementById('ar-hint').style.display='flex';
                document.getElementById('ar-scan-text').innerText = "TAP para Fijar, Pellizcar para Escalar";
                document.getElementById('ar-scale-hint').style.display = 'block';

                // Mostrar controles de AR para el Host
                showArControls();
                document.getElementById('btn-ar-accept').innerText = "ACEPTAR POSICIÓN";
                document.getElementById('btn-ar-recal').style.display = 'inline-block';
            }
        }

        // --- FUNCIONES DE JUEGO ---

        // Generación de puntos (Tablero Caótico)
        function genPoints() {
            const p=[]; const count=16; const minD=0.25;
            for(let i=0;i<count;i++){
                let v=false, pt, att=0;
                while(!v && att<100){
                    pt = { x:(Math.random()-0.5)*1.8, y:0, z:(Math.random()-0.5)*1.8 };
                    let ok=true; for(let ex of p) if(Math.hypot(ex.x-pt.x, ex.z-pt.z) < minD) ok=false;
                    if(ok) v=true; att++;
                }
                p.push(pt);
            }
            return p;
        }

        // Regla: No cruzar muros sólidos (triángulos conquistados)
        function intersect(a, b, c, d) {
            const x1=a.x, y1=a.z, x2=b.x, y2=b.z, x3=c.x, y3=c.z, x4=d.x, y4=d.z;
            const denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1);
            if (denom === 0) return false;
            const ua = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom;
            const ub = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom;
            return (ua > 0.01 && ua < 0.99 && ub > 0.01 && ub < 0.99); // Excluir extremos
        }
        function checkCollision(p1, p2, tris) {
            const A = pts[p1].position; const B = pts[p2].position;
            for (let t of tris) {
                const v1=pts[t.p1].position; const v2=pts[t.p2].position; const v3=pts[t.p3].position;
                // Verificar intersección con las 3 líneas del triángulo conquistado
                if (intersect(A, B, v1, v2) || intersect(A, B, v2, v3) || intersect(A, B, v3, v1)) return true;
            }
            return false;
        }
        // Regla: No inclusión de otro punto
        function isPointInTriangle(p, a, b, c) {
            const area = 0.5 * (-b.z * c.x + a.z * (-b.x + c.x) + a.x * (b.z - c.z) + b.x * c.z);
            const sign = area < 0 ? -1 : 1;
            const s = (a.z * c.x - a.x * c.z + (c.z - a.z) * p.x + (a.x - c.x) * p.z) * sign;
            const t = (a.x * b.z - a.z * b.x + (a.z - b.z) * p.x + (b.x - a.x) * p.z) * sign;
            // Usamos un pequeño margen para inclusión de puntos casi-colineales
            return s > 0.001 && t > 0.001 && (s + t) < 2 * area * sign - 0.001;
        }

        // CORRECCIÓN 1: Asegurar que buildBoard limpia y reconstruye el tablero.
        function buildBoard() {
            if(!S.data || !S.data.points || !group) {
                console.error("No se puede construir el tablero: Datos de juego o escena 3D faltantes.");
                return;
            }

            // Limpiamos y reconstruimos el tablero: CRUCIAL para cada nueva partida
            while(group.children.length > 0) group.remove(group.children[0]);
            pts = [];
            
            const geo=new THREE.SphereGeometry(0.04,32,32); 
            const mat=new THREE.MeshStandardMaterial({color:0x111111, emissive:0x00f3ff, emissiveIntensity:2}); 
            const hGeo=new THREE.SphereGeometry(0.15); // Hitbox Aumentado
            const hMat=new THREE.MeshBasicMaterial({visible:false});
            
            S.data.points.forEach((p,i)=>{
                const m=new THREE.Mesh(geo,mat.clone()); 
                m.position.set(p.x,p.y,p.z); 
                m.userData.id=i;
                
                // Hitbox para mejor precisión en móvil
                const h=new THREE.Mesh(hGeo,hMat); 
                m.add(h); 
                
                // Efecto de glow en el punto
                const glow=new THREE.Mesh(new THREE.SphereGeometry(0.06,16,16), new THREE.MeshBasicMaterial({color:0x00f3ff, transparent:true, opacity:0.3})); 
                m.add(glow);
                
                group.add(m); 
                pts.push(m);
            });
            
            // Forzar draw() para que dibuje líneas y triángulos si existen datos.
            draw();
            
            // Aseguramos que el grupo es visible en modo 3D (si no estamos en sesión AR)
            if (ren && !ren.xr.isPresenting) {
                group.visible = true;
                placed = true;
                recenter(); // Asegura la posición y escala inicial para 3D
            }
        }

        // --- FIN FUNCIONES DE JUEGO ---


        // AUTH & NAVIGATION
        onAuthStateChanged(auth, async u => {
            S.user = u;
            // Solo navegar si la UI está en la pantalla de login. Esto corrige el error de "bucle"
            if(u) { 
                if (document.getElementById('s-login').classList.contains('hidden')) {
                    return;
                }
                document.getElementById('u-name').innerText = u.displayName ? u.displayName.split(' ')[0].toUpperCase() : u.uid.substring(0,8).toUpperCase(); 
                nav('s-menu'); 
                checkAR(); // Inicializa el hardware 3D/AR en el menú
            } else {
                nav('s-login'); 
            }
        });
        
        window.doLogin = async () => { 
            try{ 
                showLoad(true, "INGRESANDO...");
                // Autenticación con Google
                await signInWithPopup(auth, new GoogleAuthProvider()); 
            } catch(e) { 
                showLoad(false);
                systemToast("ERROR","Inicio de sesión fallido. Habilite popups."); 
                console.error("Google Sign-In Error:", e);
            } 
        };
        window.logout = () => { 
            // Usamos confirm() porque está fuera del loop de juego y es una acción destructiva.
            if (confirm("¿Cerrar sesión?")) {
                if (S.room && S.room !== 'CPU') {
                    // Si es Host, termina la sala antes de cerrar sesión
                    if (S.role === 'host') update({ stat: 'end' }).finally(() => signOut(auth).then(() => location.reload()));
                    // Si es Guest, simplemente vuelve a casa y luego cierra sesión
                    else goHome().finally(() => signOut(auth).then(() => location.reload()));
                } else {
                    signOut(auth).then(() => location.reload());
                }
            }
        };

        function nav(id) {
            ['s-login','s-menu','s-game','win-screen'].forEach(i => {
                const el = document.getElementById(i);
                el.classList.add('hidden');
                if(i === 'win-screen') el.classList.remove('active');
            });
            const target = document.getElementById(id);
            target.classList.remove('hidden');
            if(id === 'win-screen') target.classList.add('active');
        }
        
        window.goHome = () => {
            if(roomUnsub) roomUnsub(); roomUnsub=null; S.room = null; S.data = null;
            nav('s-menu');
            // Limpieza y reinicio de AR
            isArHost = false;
            placementAccepted = false;
            hideArControls();
            
            // Limpiamos los objetos 3D del grupo
            if(group) { while(group.children.length>0) group.remove(group.children[0]); }
            
            // CORRECCIÓN: Usar el toast de sistema (el inferior) para mensajes generales
            systemToast("SISTEMA", "DESCONECTADO");
        }
        
        // CORRECCIÓN: Función para volver al menú después de la pantalla de victoria
        window.goHomeAfterWin = () => {
            // Espera un momento para que el usuario vea la pantalla de victoria
            setTimeout(window.goHome, 500);
        }

        window.setProf = (t,v,el) => {
            S.prof[t]=v; 
            const parent = el.parentNode; 
            Array.from(parent.children).forEach(c=>{ 
                c.classList.remove('active'); 
                if(t==='c') { c.style.boxShadow='none'; c.style.borderColor='#333'; }
                else { c.style.color='#555'; c.style.textShadow='none'; c.style.transform='scale(1)'; }
            });
            el.classList.add('active'); 
            if(t==='c') { 
                el.style.boxShadow=`0 0 15px ${v}`; 
                el.style.borderColor='#fff'; 
                const activeIcon = document.querySelector('#i-pick .opt-i.active');
                if(activeIcon) {
                    activeIcon.style.color=v;
                    activeIcon.style.textShadow=`0 0 10px ${v}`;
                }
            }
            else { 
                const currentProfileColor = S.prof.c;
                el.style.color=currentProfileColor; 
                el.style.textShadow=`0 0 10px ${currentProfileColor}`; 
                el.style.transform='scale(1.2)'; 
            }
        }
        window.showJoin = () => document.getElementById('join-box').classList.toggle('hidden');
        function showLoad(show, txt) { const l = document.getElementById('mini-loader'); if(show) { l.classList.remove('hidden'); document.getElementById('mini-load-txt').innerText=txt; } else l.classList.add('hidden'); }
        function hideArControls() { document.getElementById('ar-controls').classList.add('hidden'); document.getElementById('ar-controls').classList.remove('flex'); }
        function showArControls() { document.getElementById('ar-controls').classList.remove('hidden'); document.getElementById('ar-controls').classList.add('flex'); }

        // FIREBASE & LOGICA DE SALAS
        const ROOMS_COLL = collection(db, 'artifacts', appId, 'public', 'data', 'rooms');

        window.quickMatch = async () => {
            if(!S.user || !S.user.uid) return systemToast("ERROR","Debe iniciar sesión para jugar online.");
            S.cpu=false; showLoad(true,"BUSCANDO PARTIDA PÚBLICA...");
            try {
                const roomSnapshot = await getDocs(ROOMS_COLL);
                let foundRoomId = null; 
                roomSnapshot.forEach(doc => { 
                    const data = doc.data(); 
                    if(data.stat==='wait' && data.pub === true && data.host !== S.user.uid) { 
                        foundRoomId = doc.id.replace('room_',''); 
                    } 
                });
                
                if(foundRoomId) {
                    await join(foundRoomId);
                } else {
                    await create(true);
                }
            } catch(e) { 
                console.error("QuickMatch error:", e); 
                showLoad(false); 
                systemToast("ERROR","Fallo al buscar/crear sala pública."); 
            }
        };

        window.createRoom = () => create(false);
        window.joinRoom = () => { 
            const c=document.getElementById('code-in').value.toUpperCase(); 
            if(c.length===4) join(c);
            else systemToast("ERROR", "Código inválido (4 letras)");
        };
        
        // Lógica de selección de color para la CPU (Asegura color diferente)
        window.vsCpu = () => {
            if(!S.user) return systemToast("ERROR", "Debe iniciar sesión para jugar.");
            
            S.cpu=true; S.role='host'; S.room='CPU';
            
            // Colores disponibles para la CPU
            const availableColors = ['#00f3ff', '#ff0055', '#39ff14', '#ffd700'];
            
            // El color actual del jugador
            const myColor = S.prof.c;

            // Filtra el color del jugador para obtener los colores restantes
            const cpuColorOptions = availableColors.filter(color => color !== myColor);
            
            // Si hay opciones, la CPU elige una aleatoria; si no, usa el rojo por defecto
            const cpuColor = cpuColorOptions.length > 0 
                ? cpuColorOptions[Math.floor(Math.random() * cpuColorOptions.length)]
                : '#ff0055'; 

            // Generamos un estado inicial de juego
            S.data={
                stat:'play', 
                turn:'host', 
                points:genPoints(), 
                lines:[], 
                tris:[], 
                sc:{host:0,guest:0}, 
                dice:null, 
                movs:0, 
                skips:0, 
                p1:S.prof, 
                // Asigna el color diferente a la CPU (p2)
                p2:{c:cpuColor,i:'atom'}, 
                scale: 1.0, 
                arPos: null, 
                arRot: null, 
                arScale: null, 
                arAccepted: false
            };
            // CORRECCIÓN 1: Iniciar el juego, lo cual llama a buildBoard()
            start();
        };

        // CORRECCIÓN 2: Crear Sala. Asegura uso del UID y manejo de errores.
        async function create(pub) {
            if(!S.user || !S.user.uid) return systemToast("ERROR","Debe iniciar sesión para crear una sala.");
            
            // Esto asegura que si ya está en una sala como host, la abandone primero.
            if (S.room && S.role === 'host') window.goHome();

            S.role='host'; 
            const c=Math.random().toString(36).substring(2,6).toUpperCase(); 
            S.room=c;
            showLoad(true, pub ? "CREANDO PÚBLICA..." : "CREANDO SALA...");
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${c}`);
            try {
                await setDoc(docRef, {
                    host:S.user.uid, // Usar el UID del usuario logueado
                    stat:'wait', 
                    pub:pub, 
                    turn:'host', 
                    points:genPoints(), 
                    lines:[], 
                    tris:[], 
                    sc:{host:0,guest:0}, 
                    dice:null, 
                    movs:0, 
                    skips:0, 
                    p1:S.prof, 
                    scale:1.0,
                    arPos: null, arRot: null, arScale: 1.0, arAccepted: false, lastUpdate: Date.now()
                });
                sub(c); 
                document.getElementById('room-lbl').innerText=pub?"PÚBLICA":c;
            } catch (e) {
                console.error("Create Room error:", e);
                showLoad(false);
                systemToast("ERROR", "Fallo al crear la sala. Verifique permisos.");
            }
        }

        // CORRECCIÓN 2: Unirse a Sala. Asegura uso del UID y manejo de errores.
        async function join(c) {
            if(!S.user || !S.user.uid) return systemToast("ERROR","Debe iniciar sesión para unirse a una sala.");
            S.role='guest'; S.room=c; showLoad(true,"UNIENDO...");
            const docId = `room_${c}`;
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', docId);
            
            try {
                const roomSnap = await getDoc(docRef);
                
                if (!roomSnap.exists()) {
                    showLoad(false);
                    systemToast("ERROR", "Sala no encontrada o código incorrecto.");
                    S.room = null;
                    return;
                }

                const roomData = roomSnap.data();
                
                if (roomData.host === S.user.uid) {
                     systemToast("ERROR", "Ya eres el Host de esta sala.");
                     S.role = 'host';
                }

                if (roomData.guest && roomData.guest !== S.user.uid) {
                    showLoad(false);
                    systemToast("ERROR", "La sala ya está llena.");
                    S.room = null;
                    return;
                }

                let updateData = { guest:S.user.uid, stat:'play', p2:S.prof };

                if(roomData.stat === 'wait') {
                    updateData = {...updateData, dice: roomData.dice || 6, movs: roomData.movs || 6, skips: 0, turn: roomData.turn || 'host', lastUpdate: Date.now()};
                }
                
                // Solo si el usuario es Guest o el campo guest estaba vacío, actualizamos.
                if (S.role === 'guest' || !roomData.guest) {
                     await updateDoc(docRef, updateData);
                } else if (S.role === 'host') {
                     // Si es host, solo suscribimos
                     showLoad(false);
                }

                sub(c); 
                document.getElementById('room-lbl').innerText=c;

            } catch(e) { 
                showLoad(false);
                systemToast("ERROR", "Fallo al intentar unirse.");
                S.room = null;
                console.error("Join error:", e);
            }
        }
        
        function sub(c) {
            if(roomUnsub) roomUnsub();
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', `room_${c}`);
            roomUnsub = onSnapshot(docRef, s => {
                if(s.exists()) {
                    const d=s.data(); S.data=d;
                    if(d.stat==='play') { 
                        if(document.getElementById('s-game').classList.contains('hidden')) start(); 
                        ui(); 
                    }
                    else if(d.stat==='wait') {
                        if(S.role==='host') showLoad(true,"ESPERANDO RIVAL...");
                    }
                    // CORRECCIÓN: Si el estado cambia a 'end' por cualquier razón (incluyendo el botón de finalizar del rival), llamamos a endGame.
                    else if(d.stat==='end') endGame(d);
                } else if(S.room) {
                    systemToast("FIN", "Sala eliminada.");
                    window.goHome();
                }
            }, err => {
                console.error("Firestore snapshot error:", err);
                systemToast("ERROR", "Pérdida de sincronización.");
            });
        }

        function start() { 
            showLoad(false); 
            nav('s-game'); 
            init3D(); // 1. Set up THREE.js scene, renderer, etc.
            buildBoard(); // 2. Ensure game objects are created and placed (CORRECCIÓN 1)
            gameStartTime = Date.now(); 
            systemToast("SISTEMA","PARTIDA INICIADA"); 

            // Lógica de AR Host/Guest
            isArHost = !S.cpu && S.role === 'host';
            placementAccepted = !S.cpu && S.data.arAccepted === true;
            
            // Si es juego online, ocultamos el botón de recentrar de modo 3D
            document.getElementById('btn-rec').style.display = S.cpu ? 'flex' : 'none';
        }

        // El botón de finalizar juego ahora activa la función `update` para cambiar el estado a 'end'.
        window.finishGame = () => {
             if (confirm("¿Estás seguro de que quieres finalizar el juego ahora?")) {
                // Esto fuerza el estado a 'end', lo que activa endGame() en ambos lados (online)
                // o directamente en el modo CPU.
                update({stat: 'end'});
            }
        }

        function checkStatus() {
            const d = S.data;
            if (d.stat !== 'play') return;
            // Lógica para revisar si quedan movimientos válidos
            let movesLeft = 0;
            for(let i=0; i<pts.length; i++) {
                for(let j=i+1; j<pts.length; j++) {
                    // Si el punto está cerca, la línea no existe y no cruza muros
                    if(pts[i].position.distanceTo(pts[j].position) < 1.2 && 
                       !d.lines.some(l=>(l.s===i&&l.e===j)||(l.s===j&&l.e===i)) && 
                       !checkCollision(i,j,d.tris)) {
                        movesLeft++;
                    }
                }
            }
            if(movesLeft === 0) update({stat: 'end'});
        }

        window.rollDice = () => {
            const d=S.data; if(d.turn!==S.role) return gameToast("ESPERA","Turno Rival"); if(d.movs>0) return gameToast("JUEGA","Usa tus líneas");
            const el=document.getElementById('dice-vis'); el.classList.add('rolling'); playSfx('roll');
            setTimeout(()=>{
                el.classList.remove('rolling'); 
                const v=Math.ceil(Math.random()*6); 
                update({dice:v, movs:v, skips:0});
                gameToast("DADO",`ENERGÍA: ${v} líneas disponibles.`);
            },500);
        };
        
        window.skipTurn = () => { 
            const d=S.data; 
            if(d.turn===S.role) { 
                const newSkips = (d.skips || 0) + 1;
                // Si ambos jugadores consecutivamente no tienen jugadas, termina la partida.
                if (newSkips >= 2) {
                    update({stat:'end'});
                } else {
                    const t = d.turn==='host'?'guest':'host'; 
                    update({movs:0, turn:t, dice:null, skips: newSkips}); 
                    gameToast("TURNO SALTADO", "Sin jugadas válidas. Pasa el turno.");
                }
            } 
        }

        function endGame(d) {
            if(document.getElementById('s-game').classList.contains('hidden')) return;
            nav('win-screen'); playSfx('end');
            
            // Determinar si yo soy el ganador
            const myScore = S.role === 'host' ? d.sc.host : d.sc.guest;
            const rivalScore = S.role === 'host' ? d.sc.guest : d.sc.host;
            
            const win = myScore > rivalScore ? 'WIN' : (myScore < rivalScore ? 'LOSE' : 'DRAW');
            
            const tit = document.getElementById('win-title'); 
            const msg = document.getElementById('win-msg');

            if(win === 'DRAW') { 
                tit.innerText = "EMPATE"; 
                tit.className = "text-6xl font-black text-warn mb-2 text-center"; 
                msg.innerText = "SIN DOMINIO"; 
            }
            else if(win === 'WIN') { 
                tit.innerText = "VICTORIA"; 
                tit.className = "text-6xl font-black text-neon mb-2 animate-pulse text-center"; 
                msg.innerText = "DOMINIO TOTAL"; 
            }
            else { 
                // Mensaje motivador aleatorio para el perdedor
                const randomMsg = LOSE_MSGS[Math.floor(Math.random() * LOSE_MSGS.length)];
                tit.innerText = "DERROTA"; 
                tit.className = "text-6xl font-black text-hot mb-2 text-center"; 
                // Aseguramos que el mensaje es motivador y aleatorio
                msg.innerText = randomMsg.toUpperCase(); 
            }
            
            document.getElementById('final-p1').innerText = myScore;
            document.getElementById('final-p2').innerText = rivalScore;
            hideArControls();
        }

        function update(o) {
            if(S.cpu) { 
                Object.assign(S.data,o); 
                // Lógica de terminación de juego CPU (solo llama a ui si no ha terminado)
                if(S.data.stat === 'end') {
                    endGame(S.data); 
                } else {
                    ui(); 
                }
            } else {
                updateDoc(doc(db,'artifacts',appId,'public','data','rooms',`room_${S.room}`), {...o, lastUpdate: Date.now()}).catch(e => {
                    console.error("Firestore update failed:", e);
                    systemToast("ERROR","No se pudo guardar la jugada.");
                });
                // En modo online, el onSnapshot se encarga de llamar a endGame en ambos clientes
            }
        }

        function ui() {
            const d=S.data;
            document.getElementById('sc-p1').innerText = S.role==='host'?d.sc.host:d.sc.guest;
            document.getElementById('sc-p2').innerText = S.role==='host'?d.sc.guest:d.sc.host;
            const b=document.getElementById('mov-hud'); const dv=document.getElementById('dice-vis');
            
            // Control del HUD y dado
            if(d.turn===S.role && d.movs>0) { 
                b.style.opacity=1; 
                document.getElementById('mov-cnt').innerText=d.movs; 
                dv.innerText=d.dice; 
                dv.style.borderColor='#00f3ff'; dv.style.color='#00f3ff'; 
            }
            else { 
                b.style.opacity=0; 
                dv.innerText=d.dice||"?"; 
                dv.style.borderColor=d.dice?'#00f3ff':'#444'; // Si hay dado pero no es tu turno, se ve el valor
                dv.style.color=d.dice?'#00f3ff':'#555'; 
            }

            // Lógica de Sincronización AR
            if(ren && ren.xr.isPresenting) {
                // Sincronización de escala/posición
                if(d.arPos) {
                    const pos = new THREE.Vector3().fromArray(d.arPos);
                    const rot = new THREE.Euler().fromArray(d.arRot);

                    if (!placed || !d.arAccepted) {
                        // Aplica la posición y rotación del host/primero
                        group.position.copy(pos);
                        group.rotation.copy(rot);
                        group.visible = true;
                        placed = true;
                        reticle.visible = false;
                    }
                    
                    // Aplicar escala sincronizada
                    currentScale = d.arScale || 1.0;
                    group.scale.set(currentScale, currentScale, currentScale);

                    // Lógica de aceptación
                    placementAccepted = d.arAccepted;
                    if (d.arAccepted) {
                         // Tablero fijo, desactivar recalibrar/aceptar
                        hideArControls();
                        document.getElementById('ar-scan-text').innerText = "TABLERO FIJO";
                        document.getElementById('ar-hint').style.display = 'flex';
                        document.getElementById('ar-scale-hint').style.display = 'block'; // Mostrar la ayuda de escala
                    } else {
                        // Esperando aceptación del host
                        showArControls();
                        document.getElementById('ar-scan-text').innerText = "Ajusta y Acepta Escala";
                        document.getElementById('ar-scale-hint').style.display = 'block'; // Mostrar la ayuda de escala
                        document.getElementById('btn-ar-accept').innerText = isArHost ? "ACEPTAR POSICIÓN" : "ESPERANDO A HOST...";
                        document.getElementById('btn-ar-accept').disabled = !isArHost;
                        document.getElementById('btn-ar-recal').style.display = isArHost ? 'inline-block' : 'none';
                    }

                } else if (isArHost && !placed) {
                    // Host esperando colocación
                    document.getElementById('ar-scan-text').innerText = "ESCANEA SUPERFICIE";
                    document.getElementById('ar-hint').style.display = 'flex';
                    document.getElementById('ar-scale-hint').style.display = 'none';
                    hideArControls();
                } else if (!isArHost && !d.arPos) {
                    // Guest esperando posición del Host
                    document.getElementById('ar-scan-text').innerText = "ESPERANDO POSICIÓN DEL HOST";
                    document.getElementById('ar-hint').style.display = 'flex';
                    document.getElementById('ar-scale-hint').style.display = 'none';
                    hideArControls();
                }

            } else {
                // Modo 3D: solo aplica escala del grupo si no es AR
                currentScale = d.scale || 1.0;
                if(group) group.scale.set(currentScale, currentScale, currentScale);
            }
            
            draw();
            
            // Lógica de CPU
            if(S.cpu && d.turn==='guest') { 
                if(d.movs===0 && !d.dice) {
                    // CPU Lanza dado
                    setTimeout(()=>update({dice:Math.ceil(Math.random()*6),movs:3, skips:0}),1000); 
                } else if(d.movs>0) {
                    // CPU Realiza jugada
                    setTimeout(cpuMove,1500);
                }
            }
            
            // Arbitro automático (solo el host chequea el estado de fin)
            if(S.role === 'host' && !S.cpu) checkStatus();
        }

        function clickPt(id) {
            const d=S.data; if(d.turn!==S.role || d.movs<=0) return gameToast("ERROR","Lanza el dado o espera tu turno");
            // En AR, solo se puede jugar si la colocación ha sido aceptada por el host.
            if(ren.xr.isPresenting && !placementAccepted && !S.cpu) return gameToast("AR SYNC", "Espera a que el Host acepte la posición.");
            
            playSfx('click');
            if(selPt===null) { selPt=id; highlight(id,true); }
            else { 
                if(selPt===id) { 
                    highlight(id,false); selPt=null; // Deseleccionar
                } else { 
                    tryLine(selPt,id); 
                    highlight(selPt,false); 
                    selPt=null; 
                } 
            }
        }

        function tryLine(p1,p2) {
            const d=S.data; const v1=pts[p1].position; const v2=pts[p2].position;
            if(v1.distanceTo(v2) * currentScale > 1.2 * currentScale) return gameToast("RANGO","Demasiado lejos"); // Rango basado en escala
            if(d.lines.some(l=>(l.s===p1&&l.e===p2)||(l.s===p2&&l.e===p1))) return gameToast("OCUPADO","Enlace existente");
            if(checkCollision(p1, p2, d.tris)) { playSfx('error'); return gameToast("BLOQUEADO", "Territorio Protegido"); }
            
            // Intentar trazar línea y chequear triángulos
            const nl=[...d.lines,{s:p1,e:p2,own:S.role}]; 
            const nt=checkTri(p1,p2,S.role,nl);
            
            const sc={...d.sc}; 
            if(nt.length) { 
                sc[S.role]+=nt.length; 
                playSfx('win'); 
                gameToast("CONQUISTA",`¡Nexo Cerrado! (+${nt.length} tris)`); 
            } else {
                gameToast("LÍNEA", "Enlace establecido.");
            }
            
            let m=d.movs-1; 
            let t=d.turn; 
            let di=d.dice; 
            if(m===0){ 
                t=t==='host'?'guest':'host'; 
                di=null; 
            }
            
            // Actualización de estado atómica
            update({lines:nl, tris:[...d.tris,...nt], sc:sc, movs:m, turn:t, dice:di, skips:0});
        }

        function checkTri(p1,p2,o,ls) {
            const f=[]; 
            for(let p3=0; p3<pts.length; p3++) {
                if(p3!==p1 && p3!==p2) {
                    // Si las dos líneas restantes existen (p1-p3 y p2-p3)
                    if(ls.some(l=>(l.s===p1&&l.e===p3)||(l.s===p3&&l.e===p1)) && ls.some(l=>(l.s===p2&&l.e===p3)||(l.s===p3&&l.e===p2))) {
                        const v1 = pts[p1].position; const v2 = pts[p2].position; const v3 = pts[p3].position;
                        let valid = true; 
                        
                        // Regla de No Inclusión: Si otro punto cae dentro, NO es válido
                        for(let i=0; i<pts.length; i++) {
                            if(i!==p1 && i!==p2 && i!==p3) {
                                if(isPointInTriangle(pts[i].position, v1, v2, v3)) { 
                                    valid=false; 
                                    break; 
                                }
                            }
                        }
                        
                        if(valid) { 
                            // Solo si el triángulo es nuevo
                            const v=[p1,p2,p3].sort(); 
                            if(!S.data.tris.some(t=>JSON.stringify([t.p1,t.p2,t.p3].sort())===JSON.stringify(v))) {
                                f.push({p1:v[0],p2:v[1],p3:v[2],own:o}); 
                            }
                        }
                    }
                }
            } 
            return f;
        }

        function cpuMove() {
            let m=null; 
            
            // Prioridad: Buscar línea que cierre un triángulo
            for(let i=0; i<pts.length; i++) {
                for(let j=i+1; j<pts.length; j++) {
                    if(pts[i].position.distanceTo(pts[j].position)<1.2 && !S.data.lines.some(l=>(l.s===i&&l.e===j)||(l.s===j&&l.e===i)) && !checkCollision(i,j,S.data.tris)) {
                        const testLines = [...S.data.lines, {s:i,e:j,own:'guest'}];
                        if (checkTri(i, j, 'guest', testLines).length > 0) {
                            m={s:i,e:j};
                            break;
                        }
                    }
                }
                if(m) break;
            }

            // Si no hay conquista, trazar una línea válida cualquiera (cercana)
            if(!m) {
                for(let i=0;i<pts.length;i++) for(let j=i+1;j<pts.length;j++) 
                    if(pts[i].position.distanceTo(pts[j].position)<0.8 && !S.data.lines.some(l=>(l.s===i&&l.e===j)||(l.s===j&&l.e===i)) && !checkCollision(i,j,S.data.tris)) { m={s:i,e:j}; break; }
            }
            
            if(m) {
                const nl=[...S.data.lines,{s:m.s,e:m.e,own:'guest'}]; 
                const nt=checkTri(m.s,m.e,'guest',nl); 
                const sc={...S.data.sc}; 
                if(nt.length) sc.guest+=nt.length;
                
                let mo=S.data.movs-1; 
                let t=S.data.turn; 
                let di=S.data.dice; 
                if(mo===0){t='host'; di=null;}
                
                update({lines:nl, tris:[...S.data.tris,...nt], sc:sc, movs:mo, turn:t, dice:di, skips:0});
            } else {
                // Si CPU no encuentra jugada, pasa el turno (simula 'SIN JUGADAS')
                update({movs:0, turn:'host', dice:null, skips: S.data.skips + 1});
            }
        }

        // --- FIN DE FUNCIONES DE JUEGO ---


        // --- FUNCIONES THREE.JS Y AR ---

        function checkAR() {
            const el = document.getElementById('ar-status');
            if('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar')
                    .then(ok => {
                        if(ok) {
                            el.innerHTML='<span class="text-neon font-bold">AR DETECTADO</span>';
                            // Si se detecta AR, inicializar 3D para el botón AR
                            if (!arInitialized) {
                                init3D(); 
                            }
                        } else el.innerText="MODO 3D (No AR)";
                    })
                    .catch(()=>el.innerText="MODO 3D (Error AR)");
            } else el.innerText="MODO 3D (PC)";
        }

        // ** CORRECCIÓN: init3D solo inicializa componentes 3D, no el tablero **
        function init3D() {
            if(arInitialized) return; // Salir si ya está inicializado
            
            arInitialized = true;
            
            scene=new THREE.Scene(); 
            cam=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.01,20);
            ren=new THREE.WebGLRenderer({antialias:true, alpha:true}); 
            ren.setSize(innerWidth,innerHeight); 
            ren.xr.enabled=true;
            ren.domElement.style.position='absolute'; ren.domElement.style.top='0'; ren.domElement.style.zIndex='1';
            document.body.appendChild(ren.domElement);
            
            navigator.xr?.isSessionSupported('immersive-ar').then(supported => {
                if(supported) {
                    const btn = ARButton.createButton(ren, {
                        requiredFeatures: ['hit-test', 'local'], 
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.body }
                    });
                    document.getElementById('ar-zone').appendChild(btn);

                    btn.addEventListener('click', ()=>{ 
                        document.getElementById('bg-canvas').style.opacity=0; 
                    });
                }
            });

            ren.xr.addEventListener('sessionstart', async (e)=>{
                // CORRECCIÓN 3: Aseguramos que arRefSpace y arHit se inicialicen para HitTest.
                try {
                    const session = ren.xr.getSession();
                    arRefSpace = await session.requestReferenceSpace('local');
                    // Solicitamos HitTestSource usando el espacio de referencia local
                    session.requestHitTestSource({space: arRefSpace}).then(h => {
                         arHit = h;
                         systemToast("AR", "Detección de superficie activada.");
                    }).catch(e => {
                        console.error("Hit test request failed:", e);
                        systemToast("AR ERROR", "Fallo al iniciar detección de plano.");
                    });
                } catch (e) {
                    console.error("Failed to get AR reference space:", e);
                }

                placed = false;
                group.visible = false; 
                reticle.visible = true; 
                document.getElementById('ar-hint').style.display = 'flex';
                document.getElementById('ar-scan-text').innerText = "ESCANEA SUPERFICIE";

                document.getElementById('btn-rec').style.display='none';
                
                // Adjuntar listener de select solo una vez
                const controller = ren.xr.getController(0);
                controller.addEventListener('select', onControllerSelect);
            });

            ren.xr.addEventListener('sessionend',()=>{ 
                // Remover listener de select
                const controller = ren.xr.getController(0);
                controller.removeEventListener('select', onControllerSelect);
                
                recenter(); 
                document.getElementById('bg-canvas').style.opacity=1; 
                document.getElementById('btn-rec').style.display='flex';
                document.getElementById('ar-hint').style.display='none';
                document.getElementById('ar-scale-hint').style.display='none';
                hideArControls();
                
                placed = false;
                reticle.visible = false;
                arHit = null; // Limpiar hit source
            });
            
            scene.add(new THREE.HemisphereLight(0xffffff,0x222222,3)); 
            group=new THREE.Group(); 
            scene.add(group);
            
            // Reticle para detección de plano en AR
            reticle=new THREE.Mesh(new THREE.RingGeometry(0.1,0.11,32).rotateX(-Math.PI/2),new THREE.MeshBasicMaterial({color:0x00f3ff}));
            reticle.visible=false; 
            reticle.matrixAutoUpdate=false; 
            scene.add(reticle);
            
            ray=new THREE.Raycaster(); 
            ren.setAnimationLoop(loop);
            
            // Gestos Pinch-to-Zoom para escalar en AR (Mantenido igual)
            window.addEventListener('touchstart', e => { 
                if(e.touches.length===2) touchDist=Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY); 
            });
            window.addEventListener('touchmove', e => {
                // Solo Host puede escalar antes de aceptar
                if(e.touches.length===2 && placed && ren.xr.isPresenting && isArHost && !placementAccepted) {
                    const newDist = Math.hypot(e.touches[0].pageX-e.touches[1].pageX, e.touches[0].pageY-e.touches[1].pageY);
                    const delta = (newDist - touchDist) * 0.01;
                    let ns = currentScale + delta; 
                    if(ns<0.1) ns=0.1; 
                    if(ns>5.0) ns=5.0;
                    currentScale = ns; 
                    group.scale.set(ns,ns,ns); 
                    touchDist = newDist;
                    // Sincronizar escala en vivo
                    update({arScale: ns});
                }
            });

            // Detección de clicks en puntos (Raycasting)
            window.addEventListener('pointerdown', (e)=>{
                if(e.target.closest('.interactive') || e.target.closest('#ar-zone')) return;
                if(ren.xr.isPresenting) return;

                const m=new THREE.Vector2((e.clientX/innerWidth)*2-1, -(e.clientY/innerHeight)*2+1);
                ray.setFromCamera(m,cam); 
                const h=ray.intersectObjects(group.children,true);
                const obj=h.find(x=>x.object.parent && x.object.parent.userData.id!==undefined); 
                if(obj) clickPt(obj.object.parent.userData.id);
            });
            
            // Controles de órbita (Modo 3D)
            controls=new OrbitControls(cam,ren.domElement); 
            recenter();
        }
        
        // Función para re-centrar la escena (Modo 3D)
        window.recenter = () => { 
            group.visible=true; 
            placed=true; 
            group.position.set(0,0,0); 
            group.rotation.set(0,0,0); 
            cam.position.set(0,2.0,0.1); 
            cam.lookAt(0,0,0); 
            currentScale=1.0; 
            group.scale.set(1,1,1); 
            if(S.room && S.room !== 'CPU') update({scale: 1.0}); // Sincronizar escala inicial
        }
        
        // Resaltar punto seleccionado
        function highlight(id,on) { 
            const m=pts[id]; 
            if(on) { 
                m.scale.set(1.5,1.5,1.5); 
                m.material.emissive.setHex(0xffffff); 
            } else { 
                m.scale.set(1,1,1); 
                m.material.emissive.setHex(0x00f3ff); 
            } 
        }

        function draw() {
            if(!S.data || !group) return;
            // Limpiar líneas y triángulos existentes
            for(let i=group.children.length-1;i>=0;i--) if(group.children[i].userData.t) group.remove(group.children[i]);
            
            // Dibujar líneas
            S.data.lines.forEach(l=>{
                const p=l.own==='host'?S.data.p1:S.data.p2; 
                const c=p?new THREE.Color(p.c):new THREE.Color('#fff');
                const p1=pts[l.s].position; const p2=pts[l.e].position;
                const g=new THREE.CylinderGeometry(0.012,0.012,p1.distanceTo(p2),8); 
                const m=new THREE.MeshBasicMaterial({color:c, emissive:c, emissiveIntensity:1.5}); 
                const o=new THREE.Mesh(g,m);
                o.position.copy(p1).lerp(p2,0.5); 
                o.lookAt(p2); 
                o.rotateX(Math.PI/2); 
                o.userData.t=true; 
                group.add(o);
            });
            
            // Dibujar triángulos (Tris)
            S.data.tris.forEach(t=>{
                const p=t.own==='host'?S.data.p1:S.data.p2; 
                const c=p?p.c:'#fff'; 
                const i=p?p.i:'gem';
                
                // Geometría del triángulo
                const v=new Float32Array([
                    pts[t.p1].position.x,pts[t.p1].position.y,pts[t.p1].position.z,
                    pts[t.p2].position.x,pts[t.p2].position.y,pts[t.p2].position.z,
                    pts[t.p3].position.x,pts[t.p3].position.y,pts[t.p3].position.z
                ]);
                const g=new THREE.BufferGeometry(); 
                g.setAttribute('position',new THREE.BufferAttribute(v,3));
                
                // Malla semi-transparente del área conquistada
                const m=new THREE.MeshBasicMaterial({color:c, opacity:0.3, transparent:true, side:THREE.DoubleSide, depthWrite:false});
                const o=new THREE.Mesh(g,m); 
                o.userData.t=true;
                
                // Icono (Marca) en el centro del triángulo
                let ig; 
                if(i==='atom') ig=new THREE.IcosahedronGeometry(0.05,0); 
                else if(i==='star') ig=new THREE.OctahedronGeometry(0.05,0); 
                else if(i==='bolt') ig=new THREE.ConeGeometry(0.03,0.08,4); 
                else ig=new THREE.IcosahedronGeometry(0.04,0); // gem
                
                // Usamos el color c del perfil (p.c) para el icono 3D
                const im=new THREE.Mesh(ig,new THREE.MeshBasicMaterial({color:c, wireframe:false, emissive:c, emissiveIntensity:0.5})); 
                
                // Centroide
                const ce=new THREE.Vector3().add(pts[t.p1].position).add(pts[t.p2].position).add(pts[t.p3].position).divideScalar(3);
                im.position.copy(ce); 
                im.position.y+=0.08; 
                
                // Animación simple del icono
                const frame = Date.now() * 0.001; 
                im.rotation.y = frame; 
                im.position.y += Math.sin(frame * 2) * 0.01;
                
                o.add(im); 
                group.add(o);
            });
        }

        // Bucle principal de animación (para 3D y AR)
        function loop(t, frame) {
            if(controls) controls.update();
            
            // Lógica de AR (Detección de plano)
            if(ren.xr.isPresenting) {
                const s=ren.xr.getSession();
                
                if (frame && arRefSpace) {
                    // Si arHit existe, intentamos obtener resultados
                    if(arHit) {
                        const h=frame.getHitTestResults(arHit);
                        
                        if(!placed && h.length && isArHost && !placementAccepted) {
                            // Colocar reticle y mover el grupo si el Host está escaneando y no ha colocado
                            reticle.visible=true; 
                            // CORRECCIÓN 3: Usamos arRefSpace en getPose
                            reticle.matrix.fromArray(h[0].getPose(arRefSpace).transform.matrix);
                            
                            // Mover el grupo visualmente al reticle mientras se escanea
                            group.position.setFromMatrixPosition(reticle.matrix); 
                            group.rotation.setFromRotationMatrix(reticle.matrix);
                            group.visible = true;
                            
                            // Actualización de UI de escaneo
                            document.getElementById('ar-scan-text').innerText = "TAP para Fijar, Pellizcar para Escalar";
                            document.getElementById('ar-hint').style.display='flex';
                            document.getElementById('ar-scale-hint').style.display = 'block';

                        } else if (!placed && h.length && !isArHost && !placementAccepted && !S.data.arPos) {
                             // Guest esperando: muestra mensaje
                            document.getElementById('ar-scan-text').innerText = "ESPERANDO POSICIÓN DEL HOST";
                        } 
                        else {
                            // Reticle oculto si ya se colocó o no se está escaneando
                            reticle.visible=false;
                        }
                    }
                }
            } else {
                // Modo 3D: Rotación simple de la escena
                if(S.data && S.data.stat==='play' && group && !controls.enabled) {
                    group.rotation.y += 0.005;
                }
            }
            ren.render(scene,cam);
        }

        // --- Funciones de Sincronización AR ---

        window.acceptScaleAndPosition = () => {
            if (!ren.xr.isPresenting || !isArHost || !placed || placementAccepted) return gameToast("ERROR", "No es tu turno de colocar.");
            
            // Guardar posición, rotación y escala actual del grupo
            const pos = group.position.toArray();
            const rot = group.rotation.toArray().slice(0, 3); // Solo x, y, z
            const scale = currentScale;

            update({
                arPos: pos, 
                arRot: rot, 
                arScale: scale, 
                arAccepted: true
            });
            gameToast("AR SYNC", "Posición del tablero fijada y sincronizada.");
        }

        window.recalibrate = () => {
            if (!ren.xr.isPresenting || !isArHost) return;
            placed = false;
            group.visible = false;
            reticle.visible = true;
            placementAccepted = false;

            // Limpiar la posición/escala en la BD para que el Guest también recalibre
            update({
                arPos: null,
                arRot: null,
                arScale: 1.0,
                arAccepted: false
            });
            gameToast("RECALIBRAR", "Vuelve a escanear la superficie para colocar.");
            hideArControls(); // Ocultar hasta la nueva colocación
        }
        
        // --- Fin Funciones de Sincronización AR ---

        // Función de Toast para mensajes no intrusivos (MENSAJES DEL JUEGO: Conquista, Línea, Rango)
        function gameToast(t,m){
            const e=document.getElementById('game-toast');
            document.getElementById('t-head').innerText=t;
            document.getElementById('t-body').innerText=m;
            e.classList.add('show');
            // La notificación se oculta después de 3 segundos
            setTimeout(()=>e.classList.remove('show'),3000);
        }
        
        // Función de Toast para mensajes de sistema (LOGIN, RED, ERROR FATAL)
        function systemToast(t,m){
            const e=document.getElementById('toast');
            document.getElementById('s-head').innerText=t;
            document.getElementById('s-body').innerText=m;
            e.classList.add('show');
            setTimeout(()=>e.classList.remove('show'),3000);
        }

        // Aseguramos que init3D se llama en el onload para tener el canvas.
        window.onload = () => {
             if (!arInitialized) {
                init3D();
            }
        };

    </script>
</body>
</html>
