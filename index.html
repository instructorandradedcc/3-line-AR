<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3 LINE-AR | Ultimate Gameplay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { theme: { extend: { colors: { cyber: '#00e5ff', neon: '#ff0055', gold: '#ffd700' } } } }
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Rajdhani', sans-serif; background-color: #050505; color: white; user-select: none; touch-action: none; }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        
        /* Efecto Cristal */
        .glass {
            background: rgba(10, 10, 15, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        
        /* Botones Cyberpunk */
        .btn-cyber {
            background: linear-gradient(45deg, rgba(0, 229, 255, 0.1), transparent);
            border: 1px solid #00e5ff; color: #00e5ff;
            text-transform: uppercase; font-family: 'Orbitron', sans-serif; letter-spacing: 2px;
            transition: all 0.3s; position: relative; overflow: hidden;
        }
        .btn-cyber:active { transform: scale(0.95); background: #00e5ff; color: black; }
        .btn-cyber.disabled { filter: grayscale(1); opacity: 0.5; pointer-events: none; }

        /* Dado Animado */
        .dice-container { perspective: 1000px; width: 60px; height: 60px; }
        .dice { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 1s; }
        .dice-face { position: absolute; width: 60px; height: 60px; background: rgba(0,0,0,0.9); border: 2px solid #00e5ff; display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: bold; color: #00e5ff; box-shadow: 0 0 10px #00e5ff; }
        .front  { transform: rotateY(0deg) translateZ(30px); }
        .back   { transform: rotateY(180deg) translateZ(30px); }
        .right  { transform: rotateY(90deg) translateZ(30px); }
        .left   { transform: rotateY(-90deg) translateZ(30px); }
        .top    { transform: rotateX(90deg) translateZ(30px); }
        .bottom { transform: rotateX(-90deg) translateZ(30px); }

        .animate-spin-dice { animation: spinDice 0.5s infinite linear; }
        @keyframes spinDice { 0% { transform: rotateX(0) rotateY(0); } 100% { transform: rotateX(360deg) rotateY(360deg); } }

        #debug-console { position: fixed; bottom: 5px; left: 5px; color: #555; font-size: 8px; pointer-events: none; z-index: 100; font-family: monospace; }
    </style>
    
    <!-- THREE.JS -->
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="debug-console"></div>

    <!-- UI PRINCIPAL -->
    <div id="ui-layer" class="flex flex-col items-center justify-center h-full w-full p-4">
        
        <!-- 1. LOGIN -->
        <div id="screen-login" class="interactive glass p-8 rounded-2xl max-w-xs w-full text-center flex flex-col gap-6">
            <div class="relative mx-auto">
                <div class="absolute inset-0 bg-cyan-500 blur-xl opacity-20"></div>
                <i class="fas fa-cube text-5xl text-cyan-400 relative z-10"></i>
            </div>
            <div>
                <h1 class="text-3xl font-black font-orbitron text-white tracking-widest">3 LINE-AR</h1>
                <p class="text-cyan-500/60 text-xs font-mono tracking-[0.3em] mt-1">CONQUISTA 3D</p>
            </div>
            <button onclick="window.handleLogin()" id="btn-login" class="btn-cyber py-4 rounded w-full font-bold">
                <i class="fab fa-google mr-2"></i> CONECTAR
            </button>
            <p id="login-msg" class="text-[10px] text-gray-500 h-4"></p>
        </div>

        <!-- 2. MENU -->
        <div id="screen-menu" class="interactive glass p-6 rounded-2xl max-w-xs w-full hidden flex-col gap-4">
            <div class="flex justify-between items-center border-b border-white/10 pb-4">
                <div class="text-left">
                    <div class="text-[10px] text-gray-400 uppercase tracking-widest">Agente</div>
                    <div id="user-name" class="text-lg font-bold font-orbitron text-white truncate w-32">...</div>
                </div>
                <button onclick="window.logout()" class="w-8 h-8 rounded-full bg-red-500/20 text-red-500 hover:bg-red-500 hover:text-white transition flex items-center justify-center"><i class="fas fa-power-off text-xs"></i></button>
            </div>

            <button onclick="window.startQuickMatch()" class="btn-cyber py-6 rounded-xl flex flex-col items-center gap-2">
                <i class="fas fa-globe text-2xl mb-1"></i>
                <span class="text-sm font-bold">MULTIPLAYER ONLINE</span>
                <span class="text-[9px] opacity-60 font-mono">PARTIDA RÁPIDA</span>
            </button>

            <button onclick="window.startSoloGame()" class="btn-cyber py-4 rounded-xl border-purple-500 text-purple-400 hover:bg-purple-500/10">
                <i class="fas fa-microchip mr-2"></i> VS CPU (OFFLINE)
            </button>
        </div>

        <!-- 3. LOBBY -->
        <div id="screen-lobby" class="interactive glass p-8 rounded-2xl max-w-xs w-full text-center hidden">
            <div class="w-12 h-12 border-4 border-t-cyan-500 border-white/10 rounded-full animate-spin mx-auto mb-6"></div>
            <h2 class="text-xl font-orbitron text-white mb-2">BUSCANDO</h2>
            <p id="lobby-status" class="text-xs text-gray-400 font-mono">Escaneando red...</p>
            <button onclick="window.location.reload()" class="mt-6 text-xs text-red-400 underline">CANCELAR</button>
        </div>

        <!-- 4. HUD JUEGO -->
        <div id="game-hud" class="absolute inset-0 hidden flex-col pointer-events-none justify-between p-4 z-50">
            <!-- Header: Puntos -->
            <div class="glass pointer-events-auto p-3 rounded-xl flex justify-between items-center border-t-2 border-cyan-500/50 shadow-lg bg-black/90">
                <div class="flex flex-col items-center w-16">
                    <span class="text-[9px] text-cyan-400 font-bold">TÚ</span>
                    <span id="score-p1" class="text-2xl font-orbitron text-white">0</span>
                </div>
                
                <!-- DADO CENTRAL -->
                <div class="flex flex-col items-center -mt-8">
                    <div id="dice-wrap" class="dice-container cursor-pointer scale-75 md:scale-100 transition hover:scale-110" onclick="window.rollDice()">
                        <div id="dice-cube" class="dice">
                            <div class="dice-face front">1</div>
                            <div class="dice-face back">6</div>
                            <div class="dice-face right">3</div>
                            <div class="dice-face left">4</div>
                            <div class="dice-face top">5</div>
                            <div class="dice-face bottom">2</div>
                        </div>
                    </div>
                    <div id="moves-badge" class="mt-2 bg-black/80 px-3 py-1 rounded text-[10px] font-bold font-orbitron text-cyan-400 border border-cyan-500/30 hidden">
                        MOVS: <span id="moves-count" class="text-white text-lg">0</span>
                    </div>
                </div>

                <div class="flex flex-col items-center w-16">
                    <span class="text-[9px] text-red-400 font-bold">RIVAL</span>
                    <span id="score-p2" class="text-2xl font-orbitron text-white">0</span>
                </div>
            </div>

            <!-- Mensajes -->
            <div id="game-toast" class="self-center bg-black/80 border border-white/20 px-6 py-4 rounded-lg text-center opacity-0 transition-all duration-500 transform translate-y-10 backdrop-blur-md">
                <h3 id="toast-title" class="text-cyan-400 font-bold font-orbitron text-lg">TITULO</h3>
                <p id="toast-desc" class="text-white text-xs font-mono mt-1">Descripción</p>
            </div>

            <!-- Controles Inferiores -->
            <div class="pointer-events-auto flex justify-center pb-6 gap-4">
                <button onclick="window.exitGame()" class="w-12 h-12 rounded-full bg-red-500/20 text-red-500 border border-red-500/50 flex items-center justify-center hover:bg-red-500 hover:text-white backdrop-blur"><i class="fas fa-times"></i></button>
                <!-- Botón oculto de DEBUG para forzar modo 3D si AR falla -->
                <button onclick="window.force3DMode()" class="w-12 h-12 rounded-full bg-gray-800 text-white border border-white/20 flex items-center justify-center text-xs font-mono">3D</button>
            </div>
        </div>

        <div id="ar-hint" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none hidden">
            <i class="fas fa-compress-arrows-alt text-4xl text-cyan-400 animate-bounce mb-2"></i>
            <p class="text-sm font-bold bg-black/50 px-3 py-1 rounded">TOCA PARA PONER EL JUEGO</p>
        </div>
    </div>

    <div id="ar-btn-place" class="interactive"></div>

    <!-- LÓGICA -->
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, updateDoc, getDocs, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // CONFIG
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'ar-3lilne';

        // ESTADO GLOBAL
        let state = {
            user: null,
            roomId: null,
            role: null, // 'host' | 'guest'
            isCPU: false,
            gameData: null,
            localDice: 0,
            movesLeft: 0
        };

        // 3D GLOBALS
        let scene, camera, renderer, controller;
        let gridGroup, reticle, points = [], lines = [], triangles = [];
        let raycaster = new THREE.Raycaster();
        let selectedPoint = null;
        let arHitSource = null, gridPlaced = false;
        let isARSupported = false;

        // --- INICIO & AUTH ---
        setPersistence(auth, browserLocalPersistence).catch(()=>{});
        onAuthStateChanged(auth, (u) => {
            state.user = u;
            if(u) {
                document.getElementById('user-name').innerText = u.displayName || 'JUGADOR';
                showScreen('screen-menu');
                checkARSupport(); // Verificar si soportamos AR al entrar
            } else {
                showScreen('screen-login');
            }
        });

        // --- UI HELPERS ---
        function showScreen(id) {
            const screens = ['screen-login', 'screen-menu', 'screen-lobby', 'game-hud'];
            screens.forEach(s => document.getElementById(s).classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        window.handleLogin = async () => {
            const btn = document.getElementById('btn-login');
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            try { await signInWithPopup(auth, new GoogleAuthProvider()); } 
            catch(e) { console.error(e); btn.innerText = "REINTENTAR"; document.getElementById('login-msg').innerText="Error de red."; }
        };
        window.logout = () => signOut(auth).then(()=>window.location.reload());

        // --- MATCHMAKING ---
        window.startQuickMatch = async () => {
            state.isCPU = false;
            showScreen('screen-lobby');
            try {
                // Buscar sala disponible (Simulación simple)
                const roomsRef = collection(db, 'artifacts', appId, 'rooms');
                const snap = await getDocs(roomsRef);
                let foundId = null;
                
                snap.forEach(d => {
                    const data = d.data();
                    if(data.status === 'waiting' && data.hostId !== state.user.uid) foundId = d.id;
                });

                if(foundId) joinRoom(foundId.replace('room_', ''));
                else createRoom();

            } catch(e) {
                console.error(e);
                // Fallback a CPU si falla la red
                if(confirm("Error de conexión. ¿Jugar Offline VS CPU?")) window.startSoloGame();
                else showScreen('screen-menu');
            }
        };

        window.startSoloGame = () => {
            state.isCPU = true;
            state.role = 'host';
            state.gameData = {
                status: 'playing', currentPlayer: 'host',
                lines: [], triangles: [], scores: { host: 0, guest: 0 },
                diceVal: 0, movesLeft: 0,
                hostName: "TÚ", guestName: "CPU"
            };
            window.launchGame();
        };

        async function createRoom() {
            state.role = 'host';
            const code = Math.random().toString(36).substring(2,6).toUpperCase();
            state.roomId = code;
            const ref = doc(db, 'artifacts', appId, 'rooms', `room_${code}`);
            
            await setDoc(ref, {
                hostId: state.user.uid, hostName: state.user.displayName,
                status: 'waiting', currentPlayer: 'host',
                lines: [], triangles: [], scores: { host: 0, guest: 0 },
                diceVal: 0, movesLeft: 0,
                createdAt: new Date().toISOString()
            });
            subscribeRoom(code);
        }

        async function joinRoom(code) {
            state.role = 'guest';
            state.roomId = code;
            const ref = doc(db, 'artifacts', appId, 'rooms', `room_${code}`);
            await updateDoc(ref, { guestId: state.user.uid, guestName: state.user.displayName, status: 'playing' });
            subscribeRoom(code);
        }

        function subscribeRoom(code) {
            onSnapshot(doc(db, 'artifacts', appId, 'rooms', `room_${code}`), (snap) => {
                if(!snap.exists()) return;
                const d = snap.data();
                state.gameData = d;
                if(d.status === 'playing' && document.getElementById('game-hud').classList.contains('hidden')) {
                    window.launchGame();
                }
                if(d.status === 'playing') updateGameState();
            });
        }

        // --- GAME LOGIC ---
        window.launchGame = () => {
            showScreen('game-hud');
            init3D();
            updateGameState();
        };

        window.rollDice = () => {
            const d = state.gameData;
            // Solo si es mi turno y NO tengo movimientos pendientes
            if(d.currentPlayer !== state.role) return showToast("NO ES TU TURNO", "Espera al rival");
            if(d.movesLeft > 0) return showToast("TIENES MOVIMIENTOS", `Te quedan ${d.movesLeft} acciones`);

            // Animación dado
            const diceEl = document.getElementById('dice-cube');
            diceEl.classList.add('animate-spin-dice');
            
            setTimeout(() => {
                diceEl.classList.remove('animate-spin-dice');
                const val = Math.floor(Math.random() * 6) + 1;
                setDiceFace(val);
                
                // Actualizar estado
                if(state.isCPU) {
                    state.gameData.diceVal = val;
                    state.gameData.movesLeft = val;
                    updateGameState();
                } else {
                    updateDoc(doc(db, 'artifacts', appId, 'rooms', `room_${state.roomId}`), { diceVal: val, movesLeft: val });
                }
                showToast(`¡SACASTE UN ${val}!`, `Tienes ${val} líneas para poner`);
            }, 600);
        };

        function setDiceFace(val) {
            const dice = document.getElementById('dice-cube');
            const rots = { 1:[0,0], 2:[-90,0], 3:[0,-90], 4:[0,90], 5:[90,0], 6:[180,0] };
            dice.style.transform = `rotateX(${rots[val][0]}deg) rotateY(${rots[val][1]}deg)`;
        }

        function updateGameState() {
            const d = state.gameData;
            
            // UI Update
            document.getElementById('score-p1').innerText = state.role==='host' ? d.scores.host : d.scores.guest;
            document.getElementById('score-p2').innerText = state.role==='host' ? d.scores.guest : d.scores.host;
            
            // Dice UI
            const movesBadge = document.getElementById('moves-badge');
            if(d.currentPlayer === state.role && d.movesLeft > 0) {
                movesBadge.classList.remove('hidden');
                document.getElementById('moves-count').innerText = d.movesLeft;
                setDiceFace(d.diceVal || 1);
            } else {
                movesBadge.classList.add('hidden');
            }

            // Renderizar Tablero (Líneas)
            // 1. Limpiar líneas que ya no existen o duplicadas visualmente
            // (Simplificación: Borramos todas las líneas visuales y repintamos las del estado para asegurar sync perfecto)
            if(gridGroup) {
                const visuals = gridGroup.children.filter(c => c.userData.isLine || c.userData.isTriangle);
                visuals.forEach(v => gridGroup.remove(v));

                // Render Líneas
                d.lines.forEach(l => drawLine3D(l.start, l.end, l.owner));
                // Render Triángulos
                d.triangles.forEach(t => drawTriangle3D(t.p1, t.p2, t.p3, t.owner));
            }

            // CPU Turn
            if(state.isCPU && d.currentPlayer === 'guest' && d.movesLeft === 0) {
                // CPU Rolls dice logic simulada
                setTimeout(() => {
                    const cpuRoll = Math.floor(Math.random() * 3) + 1; // CPU saca entre 1 y 3 para no tardar
                    state.gameData.diceVal = cpuRoll;
                    state.gameData.movesLeft = cpuRoll;
                    showToast("CPU JUEGA", `Sacó un ${cpuRoll}`);
                    setTimeout(playCPUTurn, 1000);
                }, 1500);
            } else if(state.isCPU && d.currentPlayer === 'guest' && d.movesLeft > 0) {
                setTimeout(playCPUTurn, 1000);
            }
        }

        // --- LÓGICA DE JUEGO CENTRAL ---
        function attemptMove(p1, p2) {
            const d = state.gameData;
            if(d.currentPlayer !== state.role) return showToast("ESPERA TU TURNO");
            if(d.movesLeft <= 0) return showToast("LANZA EL DADO", "Toca el dado arriba");

            // Validar Distancia (Solo adyacentes en grid 4x4)
            // Distancia ideal ~0.15. Permitimos un margen de error del 20%
            const dist = points[p1].position.distanceTo(points[p2].position);
            if(dist > 0.15 * 1.2) return showToast("MUY LEJOS", "Solo puntos vecinos");

            // Validar Existencia
            const exists = d.lines.some(l => (l.start===p1 && l.end===p2) || (l.start===p2 && l.end===p1));
            if(exists) return showToast("YA EXISTE", "Esa línea ya está ocupada");

            // MOVIMIENTO VÁLIDO
            const newLine = { start: p1, end: p2, owner: state.role };
            const newLines = [...d.lines, newLine];
            
            // Detectar Triángulos
            const newTriangles = detectTriangles(p1, p2, state.role, newLines);
            const pointsGained = newTriangles.length;
            const allTriangles = [...d.triangles, ...newTriangles];
            
            // Scores
            const newScores = { ...d.scores };
            if(pointsGained > 0) {
                newScores[state.role] += pointsGained;
                showToast("¡TRIÁNGULO!", `+${pointsGained} Puntos`);
            }

            // Actualizar Movimientos
            let moves = d.movesLeft - 1;
            let nextPlayer = d.currentPlayer;
            
            if(moves === 0) {
                nextPlayer = d.currentPlayer === 'host' ? 'guest' : 'host';
                showToast("FIN DE TURNO", "Cambio de jugador");
            }

            const updateData = {
                lines: newLines,
                triangles: allTriangles,
                scores: newScores,
                movesLeft: moves,
                currentPlayer: nextPlayer
            };

            if(state.isCPU) {
                state.gameData = { ...state.gameData, ...updateData };
                updateGameState();
            } else {
                updateDoc(doc(db, 'artifacts', appId, 'rooms', `room_${state.roomId}`), updateData);
            }
        }

        function detectTriangles(pA, pB, owner, currentLines) {
            // Buscamos un punto pC que tenga conexión con pA y con pB
            const found = [];
            // Iteramos todos los puntos posibles (0 a 15)
            for(let pC = 0; pC < 16; pC++) {
                if(pC === pA || pC === pB) continue;
                
                const hasAC = currentLines.some(l => (l.start===pA && l.end===pC) || (l.start===pC && l.end===pA));
                const hasBC = currentLines.some(l => (l.start===pB && l.end===pC) || (l.start===pC && l.end===pB));
                
                // Verificar si ese triángulo YA existe en el historial para no duplicar puntos
                // (Simplificación: Asumimos que si las líneas existen y acabamos de cerrar, es nuevo)
                if(hasAC && hasBC) {
                    // Validar si este triángulo específico ya estaba (opcional, pero bueno para robustez)
                    const triExists = state.gameData.triangles.some(t => 
                        [t.p1, t.p2, t.p3].includes(pA) && [t.p1, t.p2, t.p3].includes(pB) && [t.p1, t.p2, t.p3].includes(pC)
                    );
                    if(!triExists) {
                        found.push({ p1: pA, p2: pB, p3: pC, owner: owner });
                    }
                }
            }
            return found;
        }

        function playCPUTurn() {
            const d = state.gameData;
            // Buscar movimiento aleatorio válido
            let s, e, valid = false, tries = 0;
            while(!valid && tries < 50) {
                s = Math.floor(Math.random() * 16);
                // Buscar vecino
                for(let i=0; i<16; i++) {
                    if(i===s) continue;
                    if(points[s].position.distanceTo(points[i].position) < 0.15 * 1.2) {
                        // Checar si existe línea
                        const exists = d.lines.some(l => (l.start===s && l.end===i) || (l.start===i && l.end===s));
                        if(!exists) { e = i; valid = true; break; }
                    }
                }
                tries++;
            }
            
            if(valid) {
                // Lógica espejo de attemptMove pero para CPU
                const newLine = { start: s, end: e, owner: 'guest' };
                const newLines = [...d.lines, newLine];
                const newTriangles = detectTriangles(s, e, 'guest', newLines);
                
                const newScores = { ...d.scores };
                if(newTriangles.length > 0) newScores.guest += newTriangles.length;

                let moves = d.movesLeft - 1;
                let nextPlayer = 'guest';
                if(moves === 0) nextPlayer = 'host';

                state.gameData = {
                    ...state.gameData,
                    lines: newLines, triangles: [...d.triangles, ...newTriangles],
                    scores: newScores, movesLeft: moves, currentPlayer: nextPlayer
                };
                updateGameState();
            } else {
                // Si no hay movimientos, pasar turno (stuck prevention)
                state.gameData.movesLeft = 0;
                state.gameData.currentPlayer = 'host';
                updateGameState();
            }
        }

        // --- 3D & VISUALS ---
        async function checkARSupport() {
            if('xr' in navigator) {
                isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
            }
        }

        function init3D() {
            if(scene) return; // Ya iniciado
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
            
            const light = new THREE.HemisphereLight(0xffffff, 0x222222, 1.5);
            scene.add(light);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // CONTENEDOR DEL JUEGO
            gridGroup = new THREE.Group();
            scene.add(gridGroup);

            // PUNTOS
            const sphereGeo = new THREE.SphereGeometry(0.015, 16, 16);
            // HITBOX INVISIBLE GRANDE PARA FACILITAR TOQUE
            const hitGeo = new THREE.SphereGeometry(0.045, 8, 8); 
            const mat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.8 });
            
            for(let z=0; z<4; z++) {
                for(let x=0; x<4; x++) {
                    const p = new THREE.Mesh(sphereGeo, mat.clone());
                    p.position.set((x-1.5)*0.15, 0, (z-1.5)*0.15);
                    p.userData = { id: points.length };
                    
                    // Hitbox invisible hijo
                    const hit = new THREE.Mesh(hitGeo, new THREE.MeshBasicMaterial({ visible: false }));
                    p.add(hit);
                    
                    gridGroup.add(p);
                    points.push(p);
                }
            }

            // LÓGICA AR vs 3D
            if(isARSupported) {
                const arBtn = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
                document.getElementById('ar-btn-place').appendChild(arBtn);
                gridGroup.visible = false; // Oculto hasta colocar
                
                reticle = new THREE.Mesh(new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({ color: 0x00e5ff }));
                reticle.visible = false; reticle.matrixAutoUpdate = false;
                scene.add(reticle);

                controller = renderer.xr.getController(0);
                controller.addEventListener('select', onARSelect);
                scene.add(controller);
            } else {
                // MODO 3D AUTOMÁTICO
                window.force3DMode();
            }

            renderer.setAnimationLoop(render);
        }

        window.force3DMode = () => {
            gridGroup.visible = true;
            gridPlaced = true;
            camera.position.set(0, 0.8, 0.8);
            camera.lookAt(0, 0, 0);
            new OrbitControls(camera, renderer.domElement);
            // Input Mouse
            window.addEventListener('pointerdown', on3DClick);
            document.getElementById('ar-hint').style.display = 'none';
        };

        function render(t, frame) {
            if(frame && isARSupported) {
                const session = renderer.xr.getSession();
                if(!arHitSource && session) session.requestReferenceSpace('viewer').then(ref => session.requestHitTestSource({ space: ref }).then(s => arHitSource = s));
                
                if(arHitSource && !gridPlaced) {
                    const hit = frame.getHitTestResults(arHitSource);
                    if(hit.length > 0) {
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit[0].getPose(renderer.xr.getReferenceSpace()).transform.matrix);
                        document.getElementById('ar-hint').classList.remove('hidden');
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            renderer.render(scene, camera);
        }

        function onARSelect() {
            if(reticle.visible && !gridPlaced) {
                gridGroup.position.setFromMatrixPosition(reticle.matrix);
                gridGroup.visible = true;
                gridPlaced = true;
                reticle.visible = false;
                document.getElementById('ar-hint').classList.add('hidden');
            } else {
                // Toque en AR para seleccionar punto
                // Usamos el controller position para raycast
                const tempMatrix = new THREE.Matrix4().identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                checkIntersection();
            }
        }

        function on3DClick(e) {
            if(e.target.closest('.interactive')) return;
            const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
            raycaster.setFromCamera(mouse, camera);
            checkIntersection();
        }

        function checkIntersection() {
            // Intersectamos con los puntos (y sus hitboxes hijos implícitamente si se configura recursive, pero points contiene los meshes padre)
            // Truco: Raycast contra los hitboxes que son más grandes
            const hitboxes = [];
            points.forEach(p => hitboxes.push(p.children[0])); // El hijo 0 es el hitbox
            
            const intersects = raycaster.intersectObjects(hitboxes);
            if(intersects.length > 0) {
                const parentPoint = intersects[0].object.parent;
                handlePointClick(parentPoint);
            }
        }

        function handlePointClick(obj) {
            if(!state.gameData || state.gameData.status !== 'playing') return;
            
            if(!selectedPoint) {
                selectedPoint = obj;
                obj.material.emissive.set(0x00ffff);
                obj.scale.set(1.3, 1.3, 1.3);
            } else {
                if(selectedPoint === obj) {
                    resetSel(); // Cancelar
                } else {
                    attemptMove(selectedPoint.userData.id, obj.userData.id);
                    resetSel();
                }
            }
        }
        function resetSel() { if(selectedPoint) { selectedPoint.material.emissive.set(0x000000); selectedPoint.scale.set(1,1,1); } selectedPoint = null; }

        // --- DRAWING HELPERS ---
        function drawLine3D(id1, id2, owner) {
            const p1 = points[id1].position;
            const p2 = points[id2].position;
            const color = owner === 'host' ? 0x00e5ff : 0xff0055;
            
            const dist = p1.distanceTo(p2);
            const geo = new THREE.CylinderGeometry(0.008, 0.008, dist, 6);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            
            mesh.position.copy(p1).lerp(p2, 0.5);
            mesh.lookAt(p2);
            mesh.rotateX(Math.PI/2);
            mesh.userData.isLine = true;
            gridGroup.add(mesh);
        }

        function drawTriangle3D(id1, id2, id3, owner) {
            const p1 = points[id1].position;
            const p2 = points[id2].position;
            const p3 = points[id3].position;
            const color = owner === 'host' ? 0x00e5ff : 0xff0055;

            const geo = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                p1.x, p1.y, p1.z,
                p2.x, p2.y, p2.z,
                p3.x, p3.y, p3.z
            ]);
            geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            // Material transparente doble cara
            const mat = new THREE.MeshBasicMaterial({ 
                color: color, 
                opacity: 0.3, 
                transparent: true, 
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData.isTriangle = true;
            gridGroup.add(mesh);
        }

        function showToast(title, desc) {
            const t = document.getElementById('game-toast');
            document.getElementById('toast-title').innerText = title;
            document.getElementById('toast-desc').innerText = desc || "";
            t.classList.remove('opacity-0', 'translate-y-10');
            setTimeout(() => t.classList.add('opacity-0', 'translate-y-10'), 2000);
        }

        window.exitGame = () => {
            if(confirm("¿Salir?")) window.location.reload();
        };

    </script>
</body>
</html>

